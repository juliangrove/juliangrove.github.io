<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-10-01 Thu 01:28 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Algebraic effects in Montague semantics</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Julian Grove" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="htmlize.css"/>
<link rel="stylesheet" type="text/css" href="readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
TeX: {
Macros: {
divd: "\\ |\\ ",
IF: ["[\\![#1]\\!]",1],
banana: ["(\\!|#1|\\!)",1],
bind: ">\\!\\!>\\!\\!=",
defeq: ":\\!=",
append: ["#1\\!\\!::\\!\\!#2",2]
}
}
});
</script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Algebraic effects in Montague semantics</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org695b116">1. Algebraic effects</a></li>
<li><a href="#orgb2dd5c9">2. Making it Montagovian</a></li>
<li><a href="#org560890d">3. Graded monads</a></li>
<li><a href="#org46fe19b">4. Examples</a></li>
<li><a href="#orgfd3b160">5. Quantifiers as handlers</a></li>
</ul>
</div>
</div>
<p>
Algebraic effects and handlers provide an approach to implementing computational side effects which has gained interest within the functional programming community, notably among users of Haskell.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> Often, programmers wish to combine different notions of side effect within the same code; for example, one may wish to write a program that both reads the environment at various points, as well as logs output. In Haskell, one may use the Reader and Writer monads to accomplish these tasks, respectively. Combining notions of side effect is, in turn, usually a matter of invoking monad transformers, which furnish some underlying monad with the functionality of a new monad, yielding aspects of both (e.g., a Reader-transformed Writer monad). The use of transformers, however, generally implies that code is not totally extensible &#x2014; extra plumbing is required, for instance, for Reader code to exist peacefully in a Reader-Writer setting.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> Moreover, after extending previous monadic code into a setting in which new layers have been added to the transformer stack, its interpretation becomes fixed: if the old code involes Reader \(s_1\), and the new code involves both Reader \(s_1\) and Reader \(s_2\), then the Reader \(s_2\) layer is necessarily evaluated first.  The interest in the algebraic effects approach comes, in part, from the fact that it is designed around extensibility: multiple notions of side effect are combined algebraically and tracked within the types. The combination is relatively seamless, moreover, in the sense that no extra plumbing is required for multiple notions of effect; and it is flexible, insofar as decisions about interpretation may be delayed until a later stage &#x2014; in the definitions of handlers.
</p>

<p>
In this post, I'll experiment a little bit with the algebraic approach in the context of modeling linguistic side effects. Jirka Maršík has done significant work studying semantic phenomena from the perspective of algebraic effects and handlers, culminating in his <a href="https://hal.inria.fr/tel-01417467">2016 PhD thesis</a> (see [<a href="#marsik_algebraic_2014">Maršík and Amblard, 2014</a>,<a href="#marsik_introducing_2016">Maršík and Amblard, 2016</a>,<a href="#marsik_effects_2016">Maršík, 2016</a>]). This work, whose main features I'll briefly summarize in &sect;<a href="#org04626c8">1</a>, is cast within a typed extension of the &lambda;-calculus designed for algebraic effects. Maršík's work departs somewhat from the denotational view of meaning semanticists in the Montagovian tradition are typically accustomed to, at least on its face. He provides an operational semantics for the extended language, which includes operations and handlers, among other constructs. The semantics allows the representations provided in the extended language to be transformed into more familiar ones denoting ordinary truth-conditions (represented by simply typed &lambda;-terms). The process of mapping expressions of the extended language into the STLC, however, involves sacrificing the usual Montagovian view of the meanings of their component parts.<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup> 
</p>

<p>
I will mainly use this post is to explore how similar ideas may be expressed in a more traditional Montagovian setting. &sect;<a href="#org2d14527">2</a> begins an attempt in this direction with a framework having much of the functionality of the algebraic effects approach, cast within the simply typed &lambda;-calculus (including products). The basic strategy explored is one which views algebraic operations as variables bound (and thus given meaning) by their handlers. This view of operations allows them to be recast as &lambda;-abstractions, giving rise to an interpretation scheme on which operations denote functions on their handlers. The proposals have been implemented in Haskell, and relevant parts of the text are accompanied by their corresponding Haskell code. The full code is available <a href="https://github.com/juliangrove/algebraic-effects-montague">here</a>.
</p>

<div id="outline-container-org695b116" class="outline-2">
<h2 id="org695b116"><span class="section-number-2">1</span> Algebraic effects<a id="org04626c8"></a></h2>
<div class="outline-text-2" id="text-1">
<p>
The basic features of Maršík's approach are presented in the papers [<a href="#marsik_algebraic_2014">Maršík and Amblard, 2014</a>,<a href="#marsik_introducing_2016">Maršík and Amblard, 2016</a>], as well as in the first chapter of <a href="https://hal.inria.fr/tel-01417467">his thesis</a>. In addition to the expressions of the simply typed &lambda;-calculus, Maršík includes the constructs <i>injection</i>, <i>operation</i>, <i>handler</i>, <i>extraction</i>, and <i>exchange</i>. Unlike the simply typed fragment of his language, these constructs have types involving (for value types \(\alpha\)) the computation types \(\mathcal{F}(\alpha)\), providing the types of expressions with algebraic effects. The type of any computation with algebraic effects is indexed by an <i>effect signature</i>; that is, a set of operation symbols, along with an assignment of types to these operation symbols that indicate any parameters the associated operation takes, as well as the operation's arity. The signature that indexes the type of a computation describes the collection of operations that <i>may</i> be invoked in the computation. For example, the computation type \(\mathcal{F}_{\{\mathtt{op} : p ⤚ a\}}(\alpha)\) is the type of computations which may invoke the operation \(\mathtt{op}\) (which takes parameters of type \(p\) and which has arity \(a\)), in order to return values of type \(\alpha\).  
</p>

<p>
Where \(E\) is an arbitrary effect signature and \(\varnothing\) is the empty effect signature, the constructs of <i>injection</i>, <i>operation</i>, <i>handler</i>, <i>extraction</i>, and <i>exchange</i> have the following typing rules. (I've changed some of the symbols from the original presentation so that they more easily render with <a href="https://www.mathjax.org/">MathJax</a>.)
</p>

<p>
\[\cfrac{\Gamma \vdash M : \alpha}{\Gamma \vdash \eta M : \mathcal{F}_E(\alpha)}\eta\tag{injection}\\[3mm]\]
\[\cfrac{\Gamma \vdash M : p\hspace{5mm}\Gamma, x : a \vdash N : \mathcal{F}_E(\gamma)\hspace{5mm}\mathtt{op} : p ⤚ a \in E}{\Gamma \vdash \mathtt{op} M (\lambda x. N) : \mathcal{F}_E(\gamma)}\mathtt{op}\tag{operation}\\[3mm]\]
\[\cfrac{E = \{\mathtt{op}_i : p_i ⤚ a_i\}_{i \in I} \uplus E_f\\E^\prime = E^{\prime\prime} \uplus E_f\\{[}\Gamma \vdash M_i : p_i \rightarrow (a_i \rightarrow \mathcal{F}_{E^\prime}(\delta)) \rightarrow \mathcal{F}_{E^\prime}(\delta){]}_{i \in I}\\\Gamma \vdash N : \gamma \rightarrow \mathcal{F}_{E^\prime}(\delta)\\\Gamma \vdash O : \mathcal{F}_E(\gamma)}{\Gamma \vdash \banana{(\mathtt{op}_i : M_i)_{i \in I}, \eta : N} O : \mathcal{F}_{E^\prime}(\delta)}\banana{}\tag{handler}\\[3mm]\]
\[\cfrac{\Gamma \vdash M : \mathcal{F}_\varnothing(\alpha)}{\Gamma \vdash ⇓ M : \alpha}⇓\tag{extraction}\\[3mm]\]
\[\cfrac{\Gamma \vdash M : \alpha \rightarrow \mathcal{F}_E(\beta)}{\Gamma \vdash \mathcal{C} M : \mathcal{F}_E(\alpha \rightarrow \beta)}\mathcal{C}\tag{exchange}\]
</p>

<p>
The type of an injection is such that it may be associated with any signature \(E\); in other words, values of type \(\alpha\) may be injected into any algebra, no matter what signature it has, as a trivial computation which simply returns that value.
</p>

<p>
Explaining the typing rule for operations requires elaborating a few background conventions. The premise \(\mathtt{op} : p ⤚ a \in E\) indicates that operation \(\mathtt{op}\) takes a parameter of type \(p\) and has arity \(a\); that is, it first applies to a term of type \(p\) and then takes \(a\) -many elements of the algebra, i.e., \(a\) -many arguments of type \(\mathcal{F}_E(\gamma)\), for some value type \(\gamma\). As \(a\) is a type (rather than a cardinality), we simply follow the convention that having arity \(a\) is equivalent to being able to apply to an \(a\) -indexed family of elements of the algebra, or, in other words, to a function of type \(a \rightarrow \mathcal{F}_E(\gamma)\). Thus a binary operation, for example, may be thought of as one which applies to a \(\mathtt{Bool}\) -indexed family of elements, where \(\mathtt{Bool}\) is the type with two inhabitants: \(\mathtt{True}\) and \(\mathtt{False}\). And a unary operation may be thought of as one which applies to a \(\star\) -indexed family of elements, where \(\star\) is the unit type, having one element (also called \(\star\)). (See [<a href="#bauer_what_2019">Bauer, 2019</a>] for a really great, accessible introduction to the relationship between algebra, as traditionally conceived, and as a framework for theories of computation.) In these terms, the typing rule for operations may be read as saying that if \(\mathtt{op}\) takes a parameter of type \(p\), along with \(a\) -many arguments of an algebra with signature \(E\) containing the operation, and there is a term \(M\) of type \(p\), as well as a way of determining an element \(N\) of the algebra \(\mathcal{F}_E(\gamma)\) for each index \(x : a\), then one may apply the operation to the parameter \(M\) and the \(a\) -indexed family of elements \(\lambda x.N\) to get a new element of the algebra.
</p>

<p>
The typing rule for handlers appears the most complex. In it, \(\uplus\) denotes disjoint union (of effect signatures), and \(I\) is some set indexing a set of judgments of the form presented in the third premise. In all, the typing rule says (approximately) that if there are terms \(M_i\) taking parameters of type \(p_i\) and \(a_i\) -many arguments from an algebra with some effect signature \(E^\prime\) (where \(E^\prime\) is required to contain any operations that will <i>not</i> be handled by the \(M_i\)), along with a term \(N\) mapping values of type \(\gamma\) into this algebra, then the handler that interprets operations \(\mathtt{op}_i\) with \(M_i\) and \(\eta x\) with \(N x\) can be applied to a computation \(O\) from an algebra which has the operations \(\mathtt{op}_i\) in its signature, in order to get an element of the new algebra with signature \(E^\prime\). In summary, handlers can apply to elements of one algebra to obtain elements of another algebra by providing terms to interpret the operations of the first as functions in the second.
</p>
</div>
</div>

<div id="outline-container-orgb2dd5c9" class="outline-2">
<h2 id="orgb2dd5c9"><span class="section-number-2">2</span> Making it Montagovian<a id="org2d14527"></a></h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fe8019;">{-# LANGUAGE</span>
<span style="color: #fe8019;">    DataKinds,</span>
<span style="color: #fe8019;">    FlexibleContexts,</span>
<span style="color: #fe8019;">    FlexibleInstances,</span>
<span style="color: #fe8019;">    GADTs,</span>
<span style="color: #fe8019;">    InstanceSigs,</span>
<span style="color: #fe8019;">    MultiParamTypeClasses,</span>
<span style="color: #fe8019;">    RankNTypes,</span>
<span style="color: #fe8019;">    TypeApplications,</span>
<span style="color: #fe8019;">    TypeFamilies,</span>
<span style="color: #fe8019;">    TypeOperators,</span>
<span style="color: #fe8019;">    UnicodeSyntax #-}</span>
</pre>
</div>

<p>
\(\begin{align*}
\mathcal{F}_{\epsilon} v &= v\\
\mathcal{F}_{p ⤚ a, l} v &= (p \rightarrow (a \rightarrow \mathcal{F}_l v) \rightarrow o) \rightarrow o
\end{align*}\)
</p>

<p>
\(\begin{align*}
\eta &: v \rightarrow \mathcal{F}_\epsilon v\\
\eta\ v &= v\\[2mm]
\mathtt{op}_{p ⤚ a} &: p \rightarrow (a \rightarrow \mathcal{F}_l v) \rightarrow \mathcal{F}_{p ⤚ a, l} v\\
\mathtt{op}_{p ⤚ a}(p; k) &= \lambda h.h p k
\end{align*}\)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fb4933;">data</span> <span style="color: #d3869b;">F</span> l v <span style="color: #fb4933;">where</span>
  <span style="color: #d3869b;">Pure</span> <span style="color: #83a598;">::</span> v <span style="color: #83a598;">&#8594;</span> <span style="color: #d3869b;">F</span> '<span style="color: #d3869b;">[]</span> v
  <span style="color: #d3869b;">Impure</span> <span style="color: #83a598;">::</span> (<span style="color: #83a598;">&#8704;</span>o<span style="color: #83a598;">.</span> (p <span style="color: #83a598;">&#8594;</span> (a <span style="color: #83a598;">&#8594;</span> <span style="color: #d3869b;">F</span> l v) <span style="color: #83a598;">&#8594;</span> o) <span style="color: #83a598;">&#8594;</span> o) <span style="color: #83a598;">&#8594;</span> <span style="color: #d3869b;">F</span> ((p <span style="color: #83a598;">&#10522;</span> a) '<span style="color: #d3869b;">:</span> l) v
</pre>
</div>
</div>
</div>

<div id="outline-container-org560890d" class="outline-2">
<h2 id="org560890d"><span class="section-number-2">3</span> Graded monads</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fb4933;">instance</span> <span style="color: #d3869b;">Effect</span> <span style="color: #d3869b;">F</span> <span style="color: #fb4933;">where</span>
  <span style="color: #fb4933;">type</span> <span style="color: #d3869b;">Unit</span> <span style="color: #d3869b;">F</span> <span style="color: #83a598;">=</span> '<span style="color: #d3869b;">[]</span>
  <span style="color: #fb4933;">type</span> <span style="color: #d3869b;">Plus</span> <span style="color: #d3869b;">F</span> l1 l2 <span style="color: #83a598;">=</span> l1 <span style="color: #d3869b;">:++</span> l2
</pre>
</div>

<p>
\(\begin{align*}
\eta &: v \rightarrow \mathcal{F}_\epsilon v\\
\eta\ v &= v
\end{align*}\)
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #fabd2f;">return</span> <span style="color: #83a598;">::</span> v <span style="color: #83a598;">&#8594;</span> <span style="color: #d3869b;">F</span> '<span style="color: #d3869b;">[]</span> v
<span style="color: #fabd2f;">return</span>  <span style="color: #83a598;">=</span> <span style="color: #d3869b;">Pure</span>
</pre>
</div>

<p>
\(\begin{align*}
(\bind) &: \mathcal{F}_{l_1} v \rightarrow (v \rightarrow \mathcal{F}_{l_2} w) \rightarrow \mathcal{F}_{l_1 l_2} w\\
v \bind k &= k v& v &: \mathcal{F}_\epsilon v\\
m \bind k &= \lambda h.m\ (\lambda p, k^\prime.h\ p\ (\lambda a.k^\prime a \bind k)) & m &: \mathcal{F}_{p ⤚ a, l} v
\end{align*}\)
</p>

<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #fabd2f;">&gt;&gt;=</span>) <span style="color: #83a598;">::</span> <span style="color: #d3869b;">F</span> l1 v <span style="color: #83a598;">&#8594;</span> (v <span style="color: #83a598;">&#8594;</span> <span style="color: #d3869b;">F</span> l2 w) <span style="color: #83a598;">&#8594;</span> <span style="color: #d3869b;">F</span> (l1 <span style="color: #d3869b;">:++</span> l2) w
<span style="color: #d3869b;">Pure</span> v <span style="color: #83a598;">&gt;&gt;=</span> k <span style="color: #83a598;">=</span> k v
<span style="color: #d3869b;">Impure</span> m <span style="color: #83a598;">&gt;&gt;=</span> k <span style="color: #83a598;">=</span> <span style="color: #d3869b;">Impure</span> <span style="color: #83a598;">$</span> <span style="color: #83a598;">\</span>h <span style="color: #83a598;">&#8594;</span> m <span style="color: #83a598;">$</span> <span style="color: #83a598;">\</span>p k' <span style="color: #83a598;">&#8594;</span> h p (<span style="color: #83a598;">\</span>a <span style="color: #83a598;">&#8594;</span> k' a <span style="color: #83a598;">&gt;&gt;=</span> k)
</pre>
</div>
</div>
</div>

<div id="outline-container-org46fe19b" class="outline-2">
<h2 id="org46fe19b"><span class="section-number-2">4</span> Examples</h2>
<div class="outline-text-2" id="text-4">
<p>
\(\begin{align*}
\IF{\textit{some linguist}} &: \mathcal{F}_{((e \rightarrow t) \rightarrow t)⤚ e} e\\
\IF{\textit{some linguist}} &= \mathtt{quant}_{((e \rightarrow t) \rightarrow t) ⤚ e}(\lambda P.\exists x : \textbf{ling} x\ \&\ P x; \eta)\\
&= \lambda h.h\ (\lambda P.\exists x : \textbf{ling} x\ \&\ P x)\ (\lambda y.y)\\[2mm]
\IF{\textit{her dog}} &: \mathcal{F}_{() ⤚ \gamma} e\\
\IF{\textit{her dog}} &= \mathtt{get}_{() ⤚ \gamma}((); \lambda g.\eta (\textbf{dogOf} (\mathtt{sel} g)))\\
&= \lambda h.h\ ()\ (\lambda g, k.k (\textbf{dogOf} (\mathtt{sel} g)))\\[2mm]
(\cdot)^\triangleright &: \mathcal{F}_l e \rightarrow \mathcal{F}_{l, () ⤚ \gamma, \gamma ⤚ ()} e\\
m^\triangleright &\defeq m \bind (\lambda x.\mathtt{get}_{() ⤚ \gamma}((); \lambda g.\mathtt{put}_{\gamma ⤚ ()}(\append{x}{g}; \lambda ().\eta x)))\\
&= m \bind \lambda x, h.h\ ()\ (\lambda g, h^\prime.h^\prime\ (\append{x}{g})\ (\lambda ().x)) 
\end{align*}\)
</p>

<p>
\(\begin{align*}
(\triangleright) &: \mathcal{F}_{l_1} (v \rightarrow w) \rightarrow \mathcal{F}_{l_2} v \rightarrow \mathcal{F}_{l_1, l_2} w\\
m \triangleright n &\defeq \mu\ (\mathtt{map}\ (\lambda f.\mathtt{map}\ (\lambda x.f x)\ n)\ m)\\[2mm]
(\triangleleft) &: \mathcal{F}_{l_1} v \rightarrow \mathcal{F}_{l_2} (v \rightarrow w) \rightarrow \mathcal{F}_{l_1, l_2} w\\
m \triangleleft n &\defeq \mu\ (\mathtt{map}\ (\lambda x.\mathtt{map}\ (\lambda f.f x)\ n)\ m)
\end{align*}\)
</p>

<div class="org-src-container">
<pre class="src src-haskell">(<span style="color: #fabd2f;">&#9657;</span>) <span style="color: #83a598;">::</span> <span style="color: #d3869b;">F</span> l1 (v <span style="color: #83a598;">&#8594;</span> w) <span style="color: #83a598;">&#8594;</span> <span style="color: #d3869b;">F</span> l2 v <span style="color: #83a598;">&#8594;</span> <span style="color: #d3869b;">F</span> (l1 <span style="color: #d3869b;">:++</span> l2) w
m <span style="color: #fabd2f;">&#9657;</span> n <span style="color: #83a598;">=</span> join <span style="color: #83a598;">$</span> fmap (<span style="color: #83a598;">\</span>f <span style="color: #83a598;">&#8594;</span> fmap (<span style="color: #83a598;">\</span>x <span style="color: #83a598;">&#8594;</span> f x) n) m

(<span style="color: #fabd2f;">&#9667;</span>) <span style="color: #83a598;">::</span> <span style="color: #d3869b;">F</span> l1 v <span style="color: #83a598;">&#8594;</span> <span style="color: #d3869b;">F</span> l2 (v <span style="color: #83a598;">&#8594;</span> w) <span style="color: #83a598;">&#8594;</span> <span style="color: #d3869b;">F</span> (l1 <span style="color: #d3869b;">:++</span> l2) w
m <span style="color: #fabd2f;">&#9667;</span> n <span style="color: #83a598;">=</span> join <span style="color: #83a598;">$</span> fmap (<span style="color: #83a598;">\</span>x <span style="color: #83a598;">&#8594;</span> fmap (<span style="color: #83a598;">\</span>f <span style="color: #83a598;">&#8594;</span> f x) n) m
</pre>
</div>
</div>
</div>

<div id="outline-container-orgfd3b160" class="outline-2">
<h2 id="orgfd3b160"><span class="section-number-2">5</span> Quantifiers as handlers</h2>
<div class="outline-text-2" id="text-5">
<div id="bibliography">
<h2>References</h2>

<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="atkey_parameterised_2009">Atkey, 2009</a>]
</td>
<td class="bibtexitem">
Atkey, R. (2009).
 Parameterised notions of computation.
 <em>Journal of Functional Programming</em>, 19(3-4):335--376.
[&nbsp;<a href="algebraic_effects_montague_bib.html#atkey_parameterised_2009">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1017/S095679680900728X">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1017/S095679680900728X">http</a>&nbsp;]
<blockquote><font size="-1">
Moggi's Computational Monads and Power et al.'s equivalent notion of Freyd category have captured a large range of computational effects present in programming languages. Examples include non-termination, non-determinism, exceptions, continuations, side effects and input/output. We present generalisations of both computational monads and Freyd categories, which we call parameterised monads and parameterised Freyd categories, that also capture computational effects with parameters. Examples of such are composable continuations, side effects where the type of the state varies and input/output where the range of inputs and outputs varies. By considering structured parameterisation also, we extend the range of effects to cover separated side effects and multiple independent streams of I/O. We also present two typed λ-calculi that soundly and completely model our categorical definitions – with and without symmetric monoidal parameterisation – and act as prototypical languages with parameterised effects.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="bauer_what_2019">Bauer, 2019</a>]
</td>
<td class="bibtexitem">
Bauer, A. (2019).
 What is algebraic about algebraic effects and handlers?
 <em>arXiv:1807.05923 [cs]</em>.
 arXiv: 1807.05923.
[&nbsp;<a href="algebraic_effects_montague_bib.html#bauer_what_2019">bib</a>&nbsp;| 
<a href="http://arxiv.org/abs/1807.05923">http</a>&nbsp;]
<blockquote><font size="-1">
This note recapitulates and expands the contents of a tutorial on the mathematical theory of algebraic effects and handlers which I gave at the Dagstuhl seminar 18172 "Algebraic effect handlers go mainstream". It is targeted roughly at the level of a doctoral student with some amount of mathematical training, or at anyone already familiar with algebraic effects and handlers as programming concepts who would like to know what they have to do with algebra. We draw an uninterrupted line of thought between algebra and computational effects. We begin on the mathematical side of things, by reviewing the classic notions of universal algebra: signatures, algebraic theories, and their models. We then generalize and adapt the theory so that it applies to computational effects. In the last step we replace traditional mathematical notation with one that is closer to programming languages.
</font></blockquote>
<blockquote><font size="-1">
Keywords: 08A70, Computer Science - Logic in Computer Science, Computer Science - Programming Languages
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="brady_programming_2013">Brady, 2013</a>]
</td>
<td class="bibtexitem">
Brady, E. (2013).
 Programming and reasoning with algebraic effects and dependent types.
 In <em>Proceedings of the 18th ACM SIGPLAN international
  conference on Functional programming</em>, ICFP '13, pages 133--144, New
  York, NY, USA. Association for Computing Machinery.
[&nbsp;<a href="algebraic_effects_montague_bib.html#brady_programming_2013">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/2500365.2500581">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1145/2500365.2500581">http</a>&nbsp;]
<blockquote><font size="-1">
One often cited benefit of pure functional programming is that pure code is easier to test and reason about, both formally and informally. However, real programs have side-effects including state management, exceptions and interactions with the outside world. Haskell solves this problem using monads to capture details of possibly side-effecting computations --- it provides monads for capturing state, I/O, exceptions, non-determinism, libraries for practical purposes such as CGI and parsing, and many others, as well as monad transformers for combining multiple effects. Unfortunately, useful as monads are, they do not compose very well. Monad transformers can quickly become unwieldy when there are lots of effects to manage, leading to a temptation in larger programs to combine everything into one coarse-grained state and exception monad. In this paper I describe an alternative approach based on handling algebraic effects, implemented in the IDRIS programming language. I show how to describe side effecting computations, how to write programs which compose multiple fine-grained effects, and how, using dependent types, we can use this approach to reason about states in effectful programs.
</font></blockquote>
<blockquote><font size="-1">
Keywords: algebraic effects, dependent types
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="charlow_semantics_2014">Charlow, 2014</a>]
</td>
<td class="bibtexitem">
Charlow, S. (2014).
 <em>On the semantics of exceptional scope</em>.
 PhD Thesis, NYU, New York.
[&nbsp;<a href="algebraic_effects_montague_bib.html#charlow_semantics_2014">bib</a>&nbsp;| 
<a href="https://semanticsarchive.net/Archive/2JmMWRjY">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="charlow_static_2019">Charlow, 2019</a>]
</td>
<td class="bibtexitem">
Charlow, S. (2019).
 Static and dynamic exceptional scope.
 Publisher: Rutgers University Published: LingBuzz.
[&nbsp;<a href="algebraic_effects_montague_bib.html#charlow_static_2019">bib</a>&nbsp;| 
<a href="https://ling.auf.net/lingbuzz/004650">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="charlow_scope_2020">Charlow, 2020</a>]
</td>
<td class="bibtexitem">
Charlow, S. (2020).
 The scope of alternatives: indefiniteness and islands.
 <em>Linguistics and Philosophy</em>, 43(4):427--472.
[&nbsp;<a href="algebraic_effects_montague_bib.html#charlow_scope_2020">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/s10988-019-09278-3">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1007/s10988-019-09278-3">http</a>&nbsp;]
<blockquote><font size="-1">
I argue that alternative-denoting expressions interact with their semantic context by taking scope. With an empirical focus on indefinites in English, I show how this approach improves on standard alternative-semantic architectures that use point-wise composition to subvert islands, as well as on in situ approaches to indefinites more generally. Unlike grammars based on point-wise composition, scope-based alternative management is thoroughly categorematic, doesn’t under-generate readings when multiple sources of alternatives occur on an island, and is compatible with standard treatments of binding. Unlike all in situ (pseudo-scope) treatments of indefinites, relying on a true scope mechanism prevents over-generation when an operator binds into an indefinite. My account relies only on function application, some mechanism for scope-taking, and two freely-applying type-shifters: the first is Karttunen’s (Linguist Philos 1(1):3–44, 1977. https://doi.org/10.1007/BF00351935) proto-question operator, aka Partee’s (in: Groenendijk, de Jongh, Stokhof (eds) Studies in discourse representation theory and the theory of generalized quantifiers, Foris, Dordrecht, 1986) IDENT, and the second can be factored out of extant approaches to the semantics of questions in the tradition of Karttunen (1977). These type-shifters form a decomposition of LIFT, the familiar function mapping values into scope-takers. Exceptional scope of alternative-generating expressions arises via (snowballing) scopal pied-piping: indefinites take scope over their island, which then itself takes scope.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="kiselyov_freer_2015">Kiselyov and Ishii, 2015</a>]
</td>
<td class="bibtexitem">
Kiselyov, O. and Ishii, H. (2015).
 Freer monads, more extensible effects.
 <em>ACM SIGPLAN Notices</em>, 50(12):94--105.
[&nbsp;<a href="algebraic_effects_montague_bib.html#kiselyov_freer_2015">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/2887747.2804319">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1145/2887747.2804319">http</a>&nbsp;]
<blockquote><font size="-1">
We present a rational reconstruction of extensible effects, the recently proposed alternative to monad transformers, as the confluence of efforts to make effectful computations compose. Free monads and then extensible effects emerge from the straightforward term representation of an effectful computation, as more and more boilerplate is abstracted away. The generalization process further leads to freer monads, constructed without the Functor constraint. The continuation exposed in freer monads can then be represented as an efficient type-aligned data structure. The end result is the algorithmically efficient extensible effects library, which is not only more comprehensible but also faster than earlier implementations. As an illustration of the new library, we show three surprisingly simple applications: non-determinism with committed choice (LogicT), catching IO exceptions in the presence of other effects, and the semi-automatic management of file handles and other resources through monadic regions. We extensively use and promote the new sort of `laziness', which underlies the left Kan extension: instead of performing an operation, keep its operands and pretend it is done.
</font></blockquote>
<blockquote><font size="-1">
Keywords: coroutine, effect handler, effect interaction, open union, type and effect system, free monad, Kan extension
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="kiselyov_extensible_2013">Kiselyov et&nbsp;al., 2013</a>]
</td>
<td class="bibtexitem">
Kiselyov, O., Sabry, A., and Swords, C. (2013).
 Extensible effects: an alternative to monad transformers.
 In <em>Proceedings of the 2013 ACM SIGPLAN symposium on
  Haskell</em>, Haskell '13, pages 59--70, New York, NY, USA. Association for
  Computing Machinery.
[&nbsp;<a href="algebraic_effects_montague_bib.html#kiselyov_extensible_2013">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1145/2503778.2503791">DOI</a>&nbsp;| 
<a href="https://doi.org/10.1145/2503778.2503791">http</a>&nbsp;]
<blockquote><font size="-1">
We design and implement a library that solves the long-standing problem of combining effects without imposing restrictions on their interactions (such as static ordering). Effects arise from interactions between a client and an effect handler (interpreter); interactions may vary throughout the program and dynamically adapt to execution conditions. Existing code that relies on monad transformers may be used with our library with minor changes, gaining efficiency over long monad stacks. In addition, our library has greater expressiveness, allowing for practical idioms that are inefficient, cumbersome, or outright impossible with monad transformers. Our alternative to a monad transformer stack is a single monad, for the coroutine-like communication of a client with its handler. Its type reflects possible requests, i.e., possible effects of a computation. To support arbitrary effects and their combinations, requests are values of an extensible union type, which allows adding and, notably, subtracting summands. Extending and, upon handling, shrinking of the union of possible requests is reflected in its type, yielding a type-and-effect system for Haskell. The library is lightweight, generalizing the extensible exception handling to other effects and accurately tracking them in types.
</font></blockquote>
<blockquote><font size="-1">
Keywords: coroutine, effect handler, effect interaction, monad, monad transformer, open union, type and effect system
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="marsik_effects_2016">Maršík, 2016</a>]
</td>
<td class="bibtexitem">
Maršík, J. (2016).
 <em>Effects and handlers in natural language</em>.
 phdthesis, Université de Lorraine.
[&nbsp;<a href="algebraic_effects_montague_bib.html#marsik_effects_2016">bib</a>&nbsp;| 
<a href="https://hal.inria.fr/tel-01417467">http</a>&nbsp;]
<blockquote><font size="-1">
In formal semantics, researchers assign meanings to sentences of a natural language. This work is guided by the principle of compositionality: the meaning of an expression is a function of the meanings of its parts. These functions are often formalized using the [lambda]-calculus. However, there are areas of language which challenge the notion of compositionality, e.g. anaphoric pronouns or presupposition triggers. These force researchers to either abandon compositionality or adjust the structure of meanings. In the first case, meanings are derived by processes that no longer correspond to pure mathematical functions but rather to context-sensitive procedures, much like the functions of a programming language that manipulate their context with side effects. In the second case, when the structure of meanings is adjusted, the new meanings tend to be instances of the same mathematical structure, the monad. Monads themselves being widely used in functional programming to encode side effects, the common theme that emerges in both approaches is the introduction of side effects. Furthermore, different problems in semantics lead to different theories which are challenging to unite. Our thesis claims that by looking at these theories as theories of side effects, we can reuse results from programming language research to combine them.This thesis extends [lambda]-calculus with a monad of computations. The monad implements effects and handlers, a recent technique in the study of programming language side effects. In the first part of the thesis, we prove some of the fundamental properties of this calculus: subject reduction, confluence and termination. Then in the second part, we demonstrate how to use the calculus to implement treatments of several linguistic phenomena: deixis, quantification, conventional implicature, anaphora and presupposition. In the end, we build a grammar that features all of these phenomena and their interactions.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="marsik_algebraic_2014">Maršík and Amblard, 2014</a>]
</td>
<td class="bibtexitem">
Maršík, J. and Amblard, M. (2014).
 Algebraic Effects and Handlers in Natural Language
  Interpretation.
 In Paiva, V.&nbsp;d., Neuper, W., Quaresma, P., Retoré, C., Moss, L.&nbsp;S.,
  and Saludes, J., editors, <em>Natural Language and Computer Science</em>,
  volume TR 2014-002 of <em>Joint Proceedings of the Second Workshop on
  Natural Language and Computer Science (NLCS'14) &amp; 1st
  International Workshop on Natural Language Services for Reasoners
  (NLSR 2014)</em>, Vienne, Austria. Center for Informatics and Systems of the
  University of Coimbra.
[&nbsp;<a href="algebraic_effects_montague_bib.html#marsik_algebraic_2014">bib</a>&nbsp;| 
<a href="https://hal.archives-ouvertes.fr/hal-01079206">http</a>&nbsp;]
<blockquote><font size="-1">
Phenomena on the syntax-semantics interface of natural languages have been observed to have links with programming language semantics, namely computa- tional effects and evaluation order. We explore this connection to be able to profit from recent development in the study of effects. We propose adopting algebraic effects and handlers as tools for facilitating a uniform and integrated treatment of different non-compositional phenomena on the syntax-semantics interface.
In this paper, we give an exposition of the framework of algebraic effects and handlers with an eye towards its applicability in computational semantics. We then present some exemplary analyses in the framework: we study the interplay of anaphora and quantification by translating the continuation-based dynamic logic of de Groote into a more DRT-like theory and we propose a treatment of overt wh-movement which avoids higher-order types in the syntax.
</font></blockquote>

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="marsik_introducing_2016">Maršík and Amblard, 2016</a>]
</td>
<td class="bibtexitem">
Maršík, J. and Amblard, M. (2016).
 Introducing a Calculus of Effects and Handlers for Natural
  Language Semantics.
 In Foret, A., Morrill, G., Muskens, R., Osswald, R., and Pogodalla,
  S., editors, <em>Formal Grammar</em>, Lecture Notes in Computer Science,
  pages 257--272, Berlin, Heidelberg. Springer.
[&nbsp;<a href="algebraic_effects_montague_bib.html#marsik_introducing_2016">bib</a>&nbsp;| 
<a href="http://dx.doi.org/10.1007/978-3-662-53042-9_15">DOI</a>&nbsp;]
<blockquote><font size="-1">
In compositional model-theoretic semantics, researchers assemble truth-conditions or other kinds of denotations using the lambda calculus. It was previously observed [26] that the lambda terms and/or the denotations studied tend to follow the same pattern: they are instances of a monad. In this paper, we present an extension of the simply-typed lambda calculus that exploits this uniformity using the recently discovered technique of effect handlers [22]. We prove that our calculus exhibits some of the key formal properties of the lambda calculus and we use it to construct a modular semantics for a small fragment that involves multiple distinct semantic phenomena.
</font></blockquote>
<blockquote><font size="-1">
Keywords: Compositionality, Conventional implicature, Deixis, Handlers, Monads, Side effects
</font></blockquote>

</td>
</tr>
</table>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">Implementations in Haskell have generally gone by the title "extensible effects". See the libraries described in [<a href="#kiselyov_extensible_2013">Kiselyov et&nbsp;al., 2013</a>] and [<a href="#kiselyov_freer_2015">Kiselyov and Ishii, 2015</a>], as well as the <a href="https://github.com/hasura/eff">eff</a> library, for some examples.</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">One can browse Haskell's popular <a href="http://hackage.haskell.org/package/mtl">Monad Transformers Library</a> for more details.</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">Maršík also provides a set-theoretic denotational semantics for his calculus in chapter 3 of <a href="https://hal.inria.fr/tel-01417467">his thesis</a>. It is not obvious, however, that this semantics can be given a simply typed encoding, at least not without special axioms; his \(\mathcal{C}\) combinator, for example, is a partial function.</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">Author: Julian Grove</p>
<p class="date">Created: 2020-10-01 Thu 01:28</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
