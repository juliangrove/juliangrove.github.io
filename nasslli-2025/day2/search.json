[
  {
    "objectID": "pds-intro/pds-intro.html#motivation",
    "href": "pds-intro/pds-intro.html#motivation",
    "title": "PDS Introduction",
    "section": "Motivation",
    "text": "Motivation\nSemantic frameworks provide powerful tools for characterizing what we can and cannot mean in using linguistic expressions.\n\nImportant properties: compositional and modular.\n\nCompositional: the meanings of complex expressions systematically computed from the meanings of smaller expressions, how they are assembled.\nModular: we can analyze one linguistic phenomenon at a time (e.g., anaphora, vagueness)‚Ä¶ then use a systematic recipe for putting the analyses together (e.g., anaphora and vagueness)."
  },
  {
    "objectID": "pds-intro/pds-intro.html#prior-approach-1",
    "href": "pds-intro/pds-intro.html#prior-approach-1",
    "title": "PDS Introduction",
    "section": "Prior approach #1",
    "text": "Prior approach #1\nChallenge: semantic frameworks don‚Äôt generally provide an apparatus for characterizing uncertainty about what we can mean in using linguistic expressions.\n\nResult: they have great difficulty characterizing:\n\nthe actual inferences that a language-comprehender draws;\nthe statistical patterns exhibited by these inferences (e.g., in a human inference dataset)."
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician‚Äôs assistant won‚Äôt admit that they laughed during the trick.\nDid the magician‚Äôs assistant laugh?"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-1",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-1",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician‚Äôs assistant won‚Äôt admit that they laughed during the trick.\nDid the magician‚Äôs assistant laugh?"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-2",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-2",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician‚Äôs assistant won‚Äôt admit that they laughed during the trick.\nDid the magician‚Äôs assistant laugh?"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-3",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-3",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician‚Äôs assistant won‚Äôt admit that they laughed during the trick.\nDid the magician‚Äôs assistant laugh?"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-4",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-4",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician‚Äôs assistant won‚Äôt admit that they laughed during the trick.\nDid the magician‚Äôs assistant laugh?"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-5",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-5",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician‚Äôs assistant won‚Äôt admit that they laughed during the trick.\nDid the magician‚Äôs assistant laugh?\n\n\nAverage response:"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-6",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-6",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician‚Äôs assistant won‚Äôt admit that they laughed during the trick.\nDid the magician‚Äôs assistant laugh?\n\n\nAverage response:"
  },
  {
    "objectID": "pds-intro/pds-intro.html#prior-approach-2",
    "href": "pds-intro/pds-intro.html#prior-approach-2",
    "title": "PDS Introduction",
    "section": "Prior approach #2",
    "text": "Prior approach #2\nFrameworks for probabilistic semantics and pragmatics provide powerful tools for characterizing uncertainty about what we can mean in using linguistics expressions:\n\nsampling from and querying arbitrary probability distributions\nrelating the output to (e.g., human) data\nformal model comparison\n\n\nChallenge: no general structure-preserving method for mapping between semantic analyses and probabilistic analyses."
  },
  {
    "objectID": "pds-intro/pds-intro.html#probabilistic-dynamic-semantics",
    "href": "pds-intro/pds-intro.html#probabilistic-dynamic-semantics",
    "title": "PDS Introduction",
    "section": "‚ÄúProbabilistic Dynamic Semantics‚Äù",
    "text": "‚ÄúProbabilistic Dynamic Semantics‚Äù\nGoal: framework where probabilistic reasoning can be added to a semantic analysis without changing its structure.\n\nResult:\n\ncharacterize and distinguish difference sources of uncertainty\nuse existing semantic theories by plugging them into the framework\nformally compare different semantic theories with each other"
  },
  {
    "objectID": "pds-intro/pds-intro.html#a-general-goal",
    "href": "pds-intro/pds-intro.html#a-general-goal",
    "title": "PDS Introduction",
    "section": "A general goal",
    "text": "A general goal\n\nHave a methodology that is widely available to linguists working on meaning.\n\n\nLarge-scale inference datasets are becoming more and more central to linguistic methodology, and semantic theory should keep up!\n\nTools to render semantic theories as probabilistic models can help catalyze things."
  },
  {
    "objectID": "pds-intro/pds-intro.html#the-basic-idea",
    "href": "pds-intro/pds-intro.html#the-basic-idea",
    "title": "PDS Introduction",
    "section": "The basic idea",
    "text": "The basic idea\nWe should think of an experimental trial as a little discourse."
  },
  {
    "objectID": "pds-intro/pds-intro.html#the-basic-idea-1",
    "href": "pds-intro/pds-intro.html#the-basic-idea-1",
    "title": "PDS Introduction",
    "section": "The basic idea",
    "text": "The basic idea\n\nSentences: Start with a prior distribution over parameters some kind (e.g., encoding world knowledge, basic meanings). Update this prior with \\(‚ü¶\\textit{s1}‚üß\\), then \\(‚ü¶\\textit{s2}‚üß\\), etc.\nQuestion: Add \\(‚ü¶\\textit{q}‚üß\\) to the stack of questions under discussion (Ginzburg 1996; Farkas and Bruce 2010).\nAnswer: Retrieve \\(‚ü¶\\textit{q}‚üß\\) from the question stack; respond (i.e., query an inference distribution)."
  },
  {
    "objectID": "pds-intro/pds-intro.html#upshot",
    "href": "pds-intro/pds-intro.html#upshot",
    "title": "PDS Introduction",
    "section": "Upshot",
    "text": "Upshot\nOnce we have modeled the entire discourse in terms of some semantic analysis, we end up with a distribution over answers to the question prompt.\n\nA distribution we can learn about from data."
  },
  {
    "objectID": "pds-intro/pds-intro.html#two-kinds-of-uncertainty",
    "href": "pds-intro/pds-intro.html#two-kinds-of-uncertainty",
    "title": "PDS Introduction",
    "section": "Two kinds of uncertainty",
    "text": "Two kinds of uncertainty\n\nresolved (or type-level) uncertainty\n\nlexical, structural, or semantic (e.g., scopal) ambiguity\n\nunresolved (or token-level) uncertainty\n\npresent on individual occasions of language use"
  },
  {
    "objectID": "pds-intro/pds-intro.html#example-of-resolved-uncertainty",
    "href": "pds-intro/pds-intro.html#example-of-resolved-uncertainty",
    "title": "PDS Introduction",
    "section": "Example of resolved uncertainty",
    "text": "Example of resolved uncertainty\n\nJo ran a race.\n\n\n\nlocomotion sense of ran\nmanagement/organizational sense of ran\n\n\nAbout nature of speech act."
  },
  {
    "objectID": "pds-intro/pds-intro.html#example-of-unresolved-uncertainty",
    "href": "pds-intro/pds-intro.html#example-of-unresolved-uncertainty",
    "title": "PDS Introduction",
    "section": "Example of unresolved uncertainty",
    "text": "Example of unresolved uncertainty\n\nJo is tall.\n\n\n\nuncertainty about Jo‚Äôs height\n\n\nIn some sense, independent of speech act."
  },
  {
    "objectID": "pds-intro/pds-intro.html#uncertainty-in-pds",
    "href": "pds-intro/pds-intro.html#uncertainty-in-pds",
    "title": "PDS Introduction",
    "section": "Uncertainty in PDS",
    "text": "Uncertainty in PDS\n\nProbability distributions may be ‚Äústacked‚Äù; this stacking is reflected in the types of semantic values.\n\nE.g., \\(\\P e\\) vs.¬†\\(\\P (\\P e)\\).\n\nResolved uncertainty: about the state of some discourse.\n\n\\(\\P œÉ\\)\n\nUnresolved uncertainty: encoded in the common ground.\n\n\\(\\P Œπ\\) (\\(Œπ\\) the type of possible worlds)\nThe common ground is an aspect of the state! \\(\\P œÉ = \\P (‚Ä¶ \\P Œπ ‚Ä¶)\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#discourse-states",
    "href": "pds-intro/pds-intro.html#discourse-states",
    "title": "PDS Introduction",
    "section": "Discourse states",
    "text": "Discourse states\n\nLists of parameters - can be arbitrarily complex.\n\nThe common ground (or context set; Stalnaker (1978))\nThe question under discussion (Roberts 2012; Ginzburg 1996)\nFarkas and Bruce (2010) stuff (e.g., projected sets)\n(Whatever you want)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#common-grounds",
    "href": "pds-intro/pds-intro.html#common-grounds",
    "title": "PDS Introduction",
    "section": "Common grounds",
    "text": "Common grounds\n\nProbability distributions over indices of some type\n\nencode what is true ‚Äúin the world‚Äù  e.g., \\(\\ct{height}(i) : e ‚Üí r\\) returns people‚Äôs heights\nmaybe certain linguistic parameters\n\ne.g., the height threshold for tall: \\(\\ct{d}_{\\textit{tall}}(i) : r\\)\n\n\n\n\nStates vs.¬†indices of the common ground\nWhat kind of thing goes where?\n\nUltimately, an empirical question."
  },
  {
    "objectID": "pds-intro/pds-intro.html#expressions-and-discourses",
    "href": "pds-intro/pds-intro.html#expressions-and-discourses",
    "title": "PDS Introduction",
    "section": "Expressions and discourses",
    "text": "Expressions and discourses\n\nmap discourse states onto probability distributions over new discourse states: \\(œÉ ‚Üí \\P (Œ± √ó œÉ^{\\prime})\\)\ncomplex linguistic acts may be sequenced\n\nan operation, bind, native to the probability monad\n\n\n\nFor instance\n\n\\(\\abbr{assert}(‚ü¶\\textit{Jo is tall}‚üß) : œÉ ‚Üí \\P (‚ãÑ √ó œÉ)\\)\n\\(\\abbr{ask}(‚ü¶\\textit{how tall?}‚üß) : œÉ ‚Üí \\P (‚ãÑ √ó \\Q Œπ r œÉ)\\)\n\\(\\abbr{assert}(‚ü¶\\textit{Jo is tall}‚üß) &gt;&gt; \\abbr{ask}(‚ü¶\\textit{how tall?}‚üß) : œÉ ‚Üí \\P (‚ãÑ √ó \\Q Œπ r œÉ)\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#response-functionslinking-models",
    "href": "pds-intro/pds-intro.html#response-functionslinking-models",
    "title": "PDS Introduction",
    "section": "Response functions/linking models",
    "text": "Response functions/linking models\n\nTake a discourse, together with a prior distribution over states‚Ä¶\nGive back a distribution over responses to the last question asked (given some testing instrument).\n\n\n\\[\n\\begin{align*}\n\\ct{respond} &: \\P œÉ ‚Üí (œÉ ‚Üí \\P (‚ãÑ √ó \\Q Œπ Œ± œÉ^{\\prime})) ‚Üí \\P œÅ\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#examples-of-linking-models",
    "href": "pds-intro/pds-intro.html#examples-of-linking-models",
    "title": "PDS Introduction",
    "section": "Examples of linking models",
    "text": "Examples of linking models\n\\[\n\\begin{align*}\n\\ct{respond} &: \\P œÉ ‚Üí (œÉ ‚Üí \\P (‚ãÑ √ó \\Q Œπ Œ± œÉ^{\\prime})) ‚Üí \\P œÅ\n\\end{align*}\n\\]\n\nLikert scale (categorical distribution); e.g., \\(œÅ = \\{\\textit{yes}, \\textit{maybe}, \\textit{no}\\}\\)\nSlider scale (truncated normal distribution);  \\(œÅ = r\\)\nBinary forced choice (Bernoulli distribution);  \\(œÅ = t\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#ccg",
    "href": "pds-intro/pds-intro.html#ccg",
    "title": "PDS Introduction",
    "section": "CCG",
    "text": "CCG\nAtomic types\n\\[\n\\begin{align*}\n\\mathcal{A} &\\Coloneqq np ‚à£ n ‚à£ s\n\\end{align*}\n\\] Noun phrases (\\(np\\)), nouns (\\(n\\)), and sentences (\\(s\\)).\n\nComplex types\n\\[\n\\begin{align*}\n\\mathcal{C}_{\\mathcal{A}} &\\Coloneqq \\mathcal{A} ‚à£ \\mathcal{C}_{\\mathcal{A}}/\\mathcal{C}_{\\mathcal{A}} ‚à£ \\mathcal{C}_{\\mathcal{A}}\\backslash\\mathcal{C}_{\\mathcal{A}}\n\\end{align*}\n\\]\nE.g., \\(s/np, s\\backslash np, np/n, (np\\backslash n)/ np, (s\\backslash s)/s\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell",
    "href": "pds-intro/pds-intro.html#haskell",
    "title": "PDS Introduction",
    "section": "Haskell",
    "text": "Haskell\n\ndata Cat = NP | N | S  -- atomic categories\n         | Cat :/: Cat -- the forward slash\n         | Cat :\\: Cat -- the backward slash\n  deriving (Eq)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#ccg-expressions",
    "href": "pds-intro/pds-intro.html#ccg-expressions",
    "title": "PDS Introduction",
    "section": "CCG expressions",
    "text": "CCG expressions\nAn expression:\n\\[\\Large\n\\begin{align*}\n  \\expr{\\textit{dog}}{Œªx, i.\\ct{dog}(i)(x)}{n}\n\\end{align*}\n\\]\n\n\\(\\textit{dog}\\) is a string.\n\\(Œªx, i.\\ct{dog}(i)(x)\\) is a meaning (reprented in the Œª-calculus).\n\nIts type is \\(e ‚Üí Œπ ‚Üí t\\).\n\n\\(n\\) is a CCG category."
  },
  {
    "objectID": "pds-intro/pds-intro.html#semantic-types-in-detail",
    "href": "pds-intro/pds-intro.html#semantic-types-in-detail",
    "title": "PDS Introduction",
    "section": "Semantic types (in detail)",
    "text": "Semantic types (in detail)\n\nAtomic types\n\\[\n\\begin{align*}\nA \\Coloneqq e ‚à£ t\n\\end{align*}\n\\]\n\n\nComplex types\n\\[\n\\begin{align*}\n   \\mathcal{T}_{A} \\Coloneqq A ‚à£ \\mathcal{T}_{A} ‚Üí \\mathcal{T}_{A} ‚à£ \\mathcal{T}_{A} √ó \\mathcal{T}_{A} ‚à£ ‚ãÑ\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-1",
    "href": "pds-intro/pds-intro.html#haskell-1",
    "title": "PDS Introduction",
    "section": "Haskell",
    "text": "Haskell\n-- | Atomic types for entities and truth values.\ndata Atom = E | T deriving (Eq, Show)\n\n-- | Arrows, and products, as well as type variables for encoding polymorphism.\ndata Type = At Atom\n          | Type :‚Üí Type\n          | Unit\n          | Type :√ó Type\n          | TyVar String\n  deriving (Eq)\n\nNote the type variables!"
  },
  {
    "objectID": "pds-intro/pds-intro.html#hindley-milner-style-polymorphism",
    "href": "pds-intro/pds-intro.html#hindley-milner-style-polymorphism",
    "title": "PDS Introduction",
    "section": "Hindley-Milner style polymorphism",
    "text": "Hindley-Milner style polymorphism\n\nGood:\n\n\\(Œªx^{Œ±}.x^{Œ±} : Œ± ‚Üí Œ±\\) ¬†¬† ü•∞\n\\(Œªx^{Œ± ‚Üí Œ≤}, y^{Œ±}.x(y)^{Œ≤} : (Œ± ‚Üí Œ≤) ‚Üí Œ± ‚Üí Œ≤\\) ¬†¬† ü•∞\n\n\n\nBad:\n\n\\(Œªf^{Œ± ‚Üí t}.f(Œªy^{Œ≤}.y^{Œ≤}) ‚àß f(Œªx^{Œ≤}, y^{Œ≥}.x^{Œ≥})\\) ¬†¬† üôÅ"
  },
  {
    "objectID": "pds-intro/pds-intro.html#typing-rules",
    "href": "pds-intro/pds-intro.html#typing-rules",
    "title": "PDS Introduction",
    "section": "Typing rules",
    "text": "Typing rules\n \\[ \\scriptsize\n\\begin{array}{c}\n\\begin{prooftree}\n\\AxiomC{}\n\\RightLabel{$\\mathtt{Ax}$}\\UnaryInfC{$Œì, x : Œ± ‚ä¢ x : Œ±$}\n\\end{prooftree}\n& \\begin{prooftree}\n\\AxiomC{$Œì, x : Œ± ‚ä¢ t : Œ≤$}\n\\RightLabel{${‚Üí}\\mathtt{I}$}\\UnaryInfC{$Œì ‚ä¢ Œªx.t : Œ± ‚Üí Œ≤$}\n\\end{prooftree}\n& \\begin{prooftree}\n\\AxiomC{$Œì ‚ä¢ t : Œ± ‚Üí Œ≤$}\n\\AxiomC{$Œì ‚ä¢ u : Œ±$}\n\\RightLabel{${‚Üí}\\mathtt{E}$}\\BinaryInfC{$Œì ‚ä¢ t(u) : Œ≤$}\n\\end{prooftree} \\\\[2mm]\n\\begin{prooftree}\n\\AxiomC{}\n\\RightLabel{$‚ãÑ\\mathtt{I}$}\\UnaryInfC{$Œì ‚ä¢ ‚ãÑ : ‚ãÑ$}\n\\end{prooftree}\n& \\begin{prooftree}\n\\AxiomC{$Œì ‚ä¢ t : Œ±$}\n\\AxiomC{$Œì ‚ä¢ u : Œ≤$}\n\\RightLabel{$√ó\\mathtt{I}$}\\BinaryInfC{$Œì ‚ä¢ ‚ü®t, u‚ü© : Œ± √ó Œ≤$}\n\\end{prooftree}\n& \\begin{prooftree}\n\\AxiomC{$Œì ‚ä¢ t : Œ±_1 √ó Œ±_2$}\n\\RightLabel{$√ó\\mathtt{E}_{j}$}\\UnaryInfC{$Œì ‚ä¢ œÄ_{j}(t) : Œ±_{j}$}\n\\end{prooftree}\n\\end{array}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#typing-rules-1",
    "href": "pds-intro/pds-intro.html#typing-rules-1",
    "title": "PDS Introduction",
    "section": "Typing rules",
    "text": "Typing rules\n\\(‚Üí\\mathtt{E}\\)\n \\[\n\\begin{prooftree}\n\\AxiomC{$Œì ‚ä¢ t : Œ± ‚Üí Œ≤$}\n\\AxiomC{$Œì ‚ä¢ u : Œ±$}\n\\RightLabel{${‚Üí}\\mathtt{E}$}\\BinaryInfC{$Œì ‚ä¢ t(u) : Œ≤$}\n\\end{prooftree}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-vanilla-terms",
    "href": "pds-intro/pds-intro.html#haskell-vanilla-terms",
    "title": "PDS Introduction",
    "section": "Haskell: vanilla terms",
    "text": "Haskell: vanilla terms\n-- | Untyped Œª-terms. Types are assigned separately (i.e., \"extrinsically\").\ndata Term = Var VarName           -- Variables.\n          | Con Constant          -- Constants.\n          | Lam VarName Term      -- Abstractions.\n          | App Term Term         -- Applications.\n          | TT                    -- The 0-tuple.\n          | Pair Term Term        -- Pairing.\n          | Pi1 Term              -- First projection.\n          | Pi2 Term              -- Second projection.\n\nTerms are ‚ÄúCurry-typed‚Äù.\n\n\nConstants:\n-- | Constants are indexed by either strings or real numbers.\ntype Constant = Either String Double"
  },
  {
    "objectID": "pds-intro/pds-intro.html#deriving-meanings",
    "href": "pds-intro/pds-intro.html#deriving-meanings",
    "title": "PDS Introduction",
    "section": "Deriving meanings",
    "text": "Deriving meanings\n\nType homomorphism\n\n\\(\\small ‚ü¶np‚üß = e \\hspace{2cm} ‚ü¶n‚üß = e ‚Üí Œπ ‚Üí t \\hspace{2cm} ‚ü¶s‚üß = Œπ ‚Üí t\\) \n\\(\\small ‚ü¶b / a‚üß = ‚ü¶b \\backslash a‚üß = ‚ü¶a‚üß ‚Üí ‚ü¶b‚üß\\)\n\n\n\nExample: application\n\n\\[\\scriptsize\n\\frac{\\expr{\\textit{every}}{Œªp^{e ‚Üí Œπ ‚Üí t}, q^{e ‚Üí Œπ ‚Üí t}, i^{Œπ}.(‚àÄy.p(y)(i) ‚Üí q(y)(i))^{t}}{s}/(s\\backslash np)/ n \\hspace{1cm} \\expr{\\textit{linguist}}{Œªx^{e}, i^{Œπ}.(\\ct{ling}(i)(x))^{t}}{n}}{\n\\expr{\\textit{every linguist}}{Œªq^{e ‚Üí Œπ ‚Üí t}, i^{Œπ}.(‚àÄy.\\ct{ling}(i)(y) ‚Üí q(y)(i))^{t}}{s}/(s\\backslash np)\n}&gt;\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#adding-probabilistic-types",
    "href": "pds-intro/pds-intro.html#adding-probabilistic-types",
    "title": "PDS Introduction",
    "section": "Adding probabilistic types",
    "text": "Adding probabilistic types\n\nNew atomic types\n\\[\nA \\Coloneqq e ‚à£ t ‚à£ r\n\\]\n\n\nNew complex types\n\\[\n\\mathcal{T}_{A} \\Coloneqq A ‚à£ \\mathcal{T}_{A} ‚Üí \\mathcal{T}_{A} ‚à£ \\mathcal{T}_{A} √ó \\mathcal{T}_{A} ‚à£ ‚ãÑ ‚à£ \\P \\mathcal{T}_{A}\n\\]\n\n\\(\\P t\\): a Bernoulli distribution‚Äîprobabilistically True or False.\n\\(\\P r\\): e.g., a normal distribution."
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-2",
    "href": "pds-intro/pds-intro.html#haskell-2",
    "title": "PDS Introduction",
    "section": "Haskell",
    "text": "Haskell\n-- | Atomic types for entities, truth values, and real numbers.\ndata Atom = E | T | R deriving (Eq, Show)\n\n-- | Arrows, products, and probabilistic types, as well as type variables for\n-- encoding polymorphism.\ndata Type = At Atom\n          | Type :‚Üí Type\n          | Unit\n          | Type :√ó Type\n          | P Type\n          | TyVar String\n  deriving (Eq)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#probabilistic-typing-rules",
    "href": "pds-intro/pds-intro.html#probabilistic-typing-rules",
    "title": "PDS Introduction",
    "section": "Probabilistic typing rules",
    "text": "Probabilistic typing rules\n \\[\n\\begin{array}{c}\n\\begin{prooftree}\n\\AxiomC{$Œì ‚ä¢ t : Œ±$}\n\\RightLabel{$\\mathtt{Return}$}\\UnaryInfC{$Œì ‚ä¢ \\pure{t} : \\P Œ±$}\n\\end{prooftree}\n& \\begin{prooftree}\n\\AxiomC{$Œì ‚ä¢ t : \\P Œ±$}\n\\AxiomC{$Œì, x : Œ± ‚ä¢ u : \\P Œ≤$}\n\\RightLabel{$\\mathtt{Bind}$}\\BinaryInfC{$Œì ‚ä¢ \\left(\\begin{array}{l} x ‚àº t \\\\ u\\end{array}\\right) : \\P Œ≤$}\n\\end{prooftree}\n\\end{array}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-probabilistic-programs",
    "href": "pds-intro/pds-intro.html#haskell-probabilistic-programs",
    "title": "PDS Introduction",
    "section": "Haskell: probabilistic programs",
    "text": "Haskell: probabilistic programs\n-- | Untyped Œª-terms. Types are assigned separately (i.e., \"extrinsically\").\ndata Term = Var VarName           -- Variables.\n          | Con Constant          -- Constants.\n          | Lam VarName Term      -- Abstractions.\n          | App Term Term         -- Applications.\n          | TT                    -- The 0-tuple.\n          | Pair Term Term        -- Pairing.\n          | Pi1 Term              -- First projection.\n          | Pi2 Term              -- Second projection.\n          | Return Term           -- Construct a degenerate distribution.\n          | Let VarName Term Term -- Sample from a distribution and continue.\n\nLet x t u ¬†¬†¬†=¬†¬†¬† \\(\\begin{array}[t]{l}\nx ‚àº t \\\\\nu\n\\end{array}\\)\nReturn t ¬†¬†¬†= ¬†¬†¬†\\(\\pure{t}\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#reweighting-distributions",
    "href": "pds-intro/pds-intro.html#reweighting-distributions",
    "title": "PDS Introduction",
    "section": "Reweighting distributions",
    "text": "Reweighting distributions\n\\[\\ct{factor} : r ‚Üí \\P ‚ãÑ\\]\n\n\\[\\begin{array}[t]{l}\nx ‚àº \\ct{mammal} \\\\\n\\ct{factor}(\\ct{hungry}(x)) \\\\\n\\pure{\\ct{mother}(x)}\n\\end{array}\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#making-observations",
    "href": "pds-intro/pds-intro.html#making-observations",
    "title": "PDS Introduction",
    "section": "Making observations",
    "text": "Making observations\n\\[\n\\begin{align*}\n\\ct{observe}\\ \\ &:\\ \\ t ‚Üí \\P ‚ãÑ \\\\\n\\ct{observe}(p)\\ \\ &=\\ \\ \\ct{factor}(ùüô(p))\n\\end{align*}\n\\]\n\n\\[\n\\begin{array}[t]{l}\nx ‚àº \\ct{mammal} \\\\\n\\ct{observe}(\\ct{dog}(x)) \\\\\n\\pure{\\ct{mother}(x)}\n\\end{array}\n\\]\n\nDistribution over mothers of mammals which are also dogs."
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-typing-constants",
    "href": "pds-intro/pds-intro.html#haskell-typing-constants",
    "title": "PDS Introduction",
    "section": "Haskell: typing constants",
    "text": "Haskell: typing constants\n-- | Assign types to constants.\ntype Sig = Constant -&gt; Maybe Type\n\n\nAn example signature\nt, r :: Type\nt = At T\nr = At R\n\ntau :: Sig\ntau = \\case\n  Left  \"factor\"  -&gt; Just (r :‚Üí P Unit)\n  Left  \"observe\" -&gt; Just (t :‚Üí P Unit)\n  Right _         -&gt; Just r"
  },
  {
    "objectID": "pds-intro/pds-intro.html#intensionality",
    "href": "pds-intro/pds-intro.html#intensionality",
    "title": "PDS Introduction",
    "section": "Intensionality",
    "text": "Intensionality\nSome intensional constants:\n\\[\n\\begin{align*}\n\\ct{see} &: Œπ ‚Üí e ‚Üí e ‚Üí t \\\\\n\\ct{ling} &: Œπ ‚Üí e ‚Üí t\n\\end{align*}\n\\]\n\nWe require other constants:\n\\[\n\\begin{align*}\n\\updct{see} &: (e ‚Üí e ‚Üí t) ‚Üí Œπ ‚Üí Œπ \\\\\n\\updct{ling} &: (e ‚Üí t) ‚Üí Œπ ‚Üí Œπ\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#how-intensional-constants-interact",
    "href": "pds-intro/pds-intro.html#how-intensional-constants-interact",
    "title": "PDS Introduction",
    "section": "How intensional constants interact",
    "text": "How intensional constants interact\n\n\\[\n\\ct{see}(\\updct{see}(p)(i)) = p \\\\\n\\]\n\n\n\\[\n\\ct{see}(\\updct{ling}(p)(i)) = \\ct{see}(i)\n\\]\n\n\n\\[\n\\ct{ling}(\\updct{ling}(p)(i)) = p \\\\\n\\]\n\n\n\\[\n\\ct{ling}(\\updct{see}(p)(i)) = \\ct{ling}(i)\n\\]\n\nCan be seen as a theory of states and locations.\n\nIndices are states.\n(Pairs of) constants are ‚Äúlocations‚Äù."
  },
  {
    "objectID": "pds-intro/pds-intro.html#the-common-ground",
    "href": "pds-intro/pds-intro.html#the-common-ground",
    "title": "PDS Introduction",
    "section": "The common ground",
    "text": "The common ground\nDefinition\nA common ground is a probabilistic program of type \\(\\P Œπ\\).\n\n\\(Œπ\\), a variable over types.\n\n\nA ‚Äústarting‚Äù index\n\\[\\ct{@} : Œπ\\]\n\nConstants that update indices can add information, to be later retrieved by intensional constants."
  },
  {
    "objectID": "pds-intro/pds-intro.html#states",
    "href": "pds-intro/pds-intro.html#states",
    "title": "PDS Introduction",
    "section": "States",
    "text": "States\nSome state-sensitive constants:\n\n\\[\n\\ct{CG} : œÉ ‚Üí \\P Œπ \\\\\n\\]\n\n\n\\[\n\\updct{CG} : \\P Œπ ‚Üí œÉ ‚Üí œÉ \\\\\n\\]\n\n\n\\[\n\\ct{QUD} : \\Q Œπ Œ± œÉ ‚Üí Œ± ‚Üí Œπ ‚Üí t\n\\]\n\n\n\\[\n\\updct{QUD} : (Œ± ‚Üí Œπ ‚Üí t) ‚Üí œÉ ‚Üí \\Q Œπ Œ± œÉ\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-the-q-constructor",
    "href": "pds-intro/pds-intro.html#haskell-the-q-constructor",
    "title": "PDS Introduction",
    "section": "Haskell: the \\(\\Q\\) constructor",
    "text": "Haskell: the \\(\\Q\\) constructor\n\n-- | Arrows, products, and probabilistic types, as well as (a) abstract types\n-- representing the addition of a new Q, and (b) type variables for encoding\n-- polymorphism.\ndata Type = At Atom\n          | Type :‚Üí Type\n          | Unit\n          | Type :√ó Type\n          | P Type\n          | Q Type Type Type\n          | TyVar String\n  deriving (Eq)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#how-stateful-constants-interact",
    "href": "pds-intro/pds-intro.html#how-stateful-constants-interact",
    "title": "PDS Introduction",
    "section": "How stateful constants interact",
    "text": "How stateful constants interact\n\\[\n\\ct{CG}(\\updct{CG}(cg)(s)) = cg\n\\]\n\n\\[\n\\ct{CG}(\\updct{QUD}(q)(s)) = \\ct{CG}(s)\n\\]\n\n\n\\[\n\\ct{QUD}(\\updct{QUD}(q)(s)) = q \\\\\n\\]\n\n\n\\[\n\\ct{QUD}(\\updct{CG}(cg)(s)) = \\ct{QUD}(s)\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#expression-meanings",
    "href": "pds-intro/pds-intro.html#expression-meanings",
    "title": "PDS Introduction",
    "section": "Expression meanings",
    "text": "Expression meanings\n\\[\n‚Ñô^{œÉ}_{œÉ^{\\prime}} Œ± ‚âù œÉ ‚Üí \\P (Œ± √ó œÉ^{\\prime})\n\\]\n\nNew type for, e.g., noun phrases: \\[\n‚Ñô^{œÉ}_{œÉ^{\\prime}}(‚ü¶np‚üß) \\,\\, = \\,\\, ‚Ñô^{œÉ}_{œÉ^{\\prime}} e \\,\\, = \\,\\, œÉ ‚Üí \\P (e √ó œÉ^{\\prime})\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#program-composition-via-parameterized-monads",
    "href": "pds-intro/pds-intro.html#program-composition-via-parameterized-monads",
    "title": "PDS Introduction",
    "section": "Program composition via parameterized monads",
    "text": "Program composition via parameterized monads\n\\[\n\\begin{align*}\n‚Ñô^{œÉ}_{œÉ^{\\prime}} Œ±\\ \\ &=\\ \\ œÉ ‚Üí \\P (Œ± √ó œÉ^{\\prime})\n\\end{align*}\n\\]\n\n\\[\n\\begin{align*}\n\\return{v}_{œÉ}\\ \\ &=\\ \\ Œªs.\\pure{‚ü®v, s‚ü©} : ‚Ñô^{œÉ}_{œÉ}\n\\end{align*}\n\\]\n\n\n\\[\n\\begin{align*}\n\\begin{array}{rl}\n\\Do_{œÉ, œÉ^{\\prime}, œÉ^{\\prime\\prime}} & x ‚Üê m : ‚Ñô^{œÉ}_{œÉ^{\\prime}} \\\\\n& k(x) : ‚Ñô^{œÉ^{\\prime}}_{œÉ^{\\prime\\prime}}\n\\end{array}\\ \\\n&=\\ \\ Œªs.\\left(\\begin{array}{l}\n‚ü®x, s^{\\prime}‚ü© ‚àº m(s) \\\\\nk(x)(s^{\\prime})\n\\end{array}\\right) : ‚Ñô^{œÉ}_{œÉ^{\\prime\\prime}}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#manipulating-stateful-programs",
    "href": "pds-intro/pds-intro.html#manipulating-stateful-programs",
    "title": "PDS Introduction",
    "section": "Manipulating stateful programs",
    "text": "Manipulating stateful programs\n\\(\\ct{get}\\) and \\(\\ct{put}\\)\n\\[\n\\begin{align*}\n\\abbr{get} &: ‚Ñô^{œÉ}_{œÉ} œÉ\n\\end{align*}\n\\]\n\nGets the current state.\n\n\n\\[\n\\begin{align*}\n\\abbr{put} &: œÉ^{\\prime} ‚Üí ‚Ñô^{œÉ}_{œÉ^{\\prime}} ‚ãÑ \\\\\n\\end{align*}\n\\]\n\nOverwrites the current state with a new one."
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-3",
    "href": "pds-intro/pds-intro.html#haskell-3",
    "title": "PDS Introduction",
    "section": "Haskell",
    "text": "Haskell\n\ngetPP :: Term\ngetPP = lam' s (Return (s & s))\n\nputPP :: Term -&gt; Term\nputPP s = Lam fr (Return (TT & s))\n  where fr:esh = fresh [s]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#pds-rules",
    "href": "pds-intro/pds-intro.html#pds-rules",
    "title": "PDS Introduction",
    "section": "PDS Rules",
    "text": "PDS Rules\nExample: rightward application/composition\n\\[ \\scriptsize\n\\begin{prooftree}\n\\AxiomC{$\\expr{s_{1}}{M_{1}}{c/ b}$}\n\\AxiomC{$\\expr{s_{2}}{M_{2}}{b‚à£_{n}a_{n}\\,\\,‚ãØ‚à£_{1}a_{1}}$}\n\\RightLabel{${&gt;}\\textbf{B}_{n}$}\\BinaryInfC{\\(\\expr{s_{1}\\,s_{2}}{\n\\begin{array}{rl}\n\\Do & \\{\\,m_{1} ‚Üê M_{1};\\,m_{2} ‚Üê M_{2}; \\\\\n& \\return{Œªx_{1}, ‚Ä¶, x_{n}.m_{1}(m_{2}(x_{1})‚Ä¶(x_{n}))}\\,\\}\n\\end{array}\n}{c‚à£_{n}a_{n}\\,\\,‚ãØ‚à£_{1}a_{1}}\\)}\n\\end{prooftree}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#asking-a-question",
    "href": "pds-intro/pds-intro.html#asking-a-question",
    "title": "PDS Introduction",
    "section": "Asking a question",
    "text": "Asking a question\n\\[\n\\begin{align*}\n\\abbr{ask} &: ‚Ñô^{œÉ}_{œÉ^{\\prime}} (Œ± ‚Üí Œπ ‚Üí t) ‚Üí ‚Ñô^{œÉ}_{\\Q Œπ Œ± œÉ^{\\prime}} ‚ãÑ\n\\end{align*}\n\\]\n\n\\[\n\\begin{align*}\n\\abbr{ask}(‚ü¶\\textit{how tall?}‚üß) &= \\begin{array}[t]{rl}\n\\Do & q^{r ‚Üí Œπ ‚Üí t} ‚Üê ‚ü¶\\textit{how tall?}‚üß^{‚Ñô^{œÉ}_{œÉ}(r ‚Üí Œπ ‚Üí t)} \\\\\n& s ‚Üê \\abbr{get} \\\\\n& \\abbr{put}(\\updct{QUD}(q)(s))\n\\end{array}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#responding-to-a-question",
    "href": "pds-intro/pds-intro.html#responding-to-a-question",
    "title": "PDS Introduction",
    "section": "Responding to a question",
    "text": "Responding to a question\n\\[\n\\begin{align*}\n\\abbr{respond}^{f_Œ¶ : r ‚Üí \\P œÅ} &: \\P œÉ ‚Üí ‚Ñô^{œÉ}_{\\Q Œπ r œÉ^{\\prime}} ‚ãÑ ‚Üí \\P œÅ\n\\end{align*}\n\\]\n\n\\[\n\\begin{align*}\n\\abbr{respond}^{f_Œ¶ : r ‚Üí \\P œÅ}(bg)(m) &= \\begin{array}[t]{l}\ns ‚àº bg \\\\\n‚ü®‚ãÑ, s^{\\prime}‚ü© ‚àº m(s) \\\\\ni ‚àº \\ct{CG}(s^{\\prime}) \\\\\nf(\\ct{max}(Œªd.\\ct{QUD}(s)(d)(i)), Œ¶)\n\\end{array}\n\\end{align*}\n\\]\n\n\nExample \\(f_{Œ¶}\\)\n\n\\(f(x, Œ¶) = \\abbr{Normal}(x, 1)\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#how-do-we-actually-compute-this-stuff",
    "href": "pds-intro/pds-intro.html#how-do-we-actually-compute-this-stuff",
    "title": "PDS Introduction",
    "section": "How do we actually compute this stuff?",
    "text": "How do we actually compute this stuff?\n\n\nDelta-rules.\n-- | The type of Delta-rules.\ntype DeltaRule = Term -&gt; Maybe Term"
  },
  {
    "objectID": "pds-intro/pds-intro.html#summing-up",
    "href": "pds-intro/pds-intro.html#summing-up",
    "title": "PDS Introduction",
    "section": "Summing up",
    "text": "Summing up\n\nWe have a computational framework for:\n\nencoding grammar fragments\nrepresenting speech acts (assertions, questions)\nrepresenting theories linking inferences to behavior (as response functions)\ncomputing with the resulting probabilistic programs (via delta-rules)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#references",
    "href": "pds-intro/pds-intro.html#references",
    "title": "PDS Introduction",
    "section": "",
    "text": "References\n\n\n\n\nFarkas, Donka F., and Kim B. Bruce. 2010. ‚ÄúOn Reacting to Assertions and Polar Questions.‚Äù Journal of Semantics 27 (1): 81‚Äì118. https://doi.org/10.1093/jos/ffp010.\n\n\nGinzburg, Jonathan. 1996. ‚ÄúDynamics and the Semantics of Dialogue.‚Äù In Logic, Language, and Computation, edited by Jerry Seligman and Dag Westerst√•hl, 1:221‚Äì37. Stanford: CSLI Publications.\n\n\nRoberts, Craige. 2012. ‚ÄúInformation Structure: Towards an Integrated Formal Theory of Pragmatics.‚Äù Semantics and Pragmatics 5 (December): 6:1‚Äì69. https://doi.org/10.3765/sp.5.6.\n\n\nStalnaker, Robert. 1978. ‚ÄúAssertion.‚Äù In Pragmatics, edited by Peter Cole, 9:315‚Äì32. New York: Academic Press."
  }
]