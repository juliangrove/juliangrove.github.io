[
  {
    "objectID": "pds-intro/pds-intro.html#motivation",
    "href": "pds-intro/pds-intro.html#motivation",
    "title": "PDS Introduction",
    "section": "Motivation",
    "text": "Motivation\nSemantic frameworks provide powerful tools for characterizing what we can and cannot mean in using linguistic expressions.\n\nImportant properties: compositional and modular.\n\nCompositional: the meanings of complex expressions systematically computed from the meanings of smaller expressions, how they are assembled.\nModular: we can analyze one linguistic phenomenon at a time (e.g., anaphora, vagueness)… then use a systematic recipe for putting the analyses together (e.g., anaphora and vagueness)."
  },
  {
    "objectID": "pds-intro/pds-intro.html#prior-approach-1",
    "href": "pds-intro/pds-intro.html#prior-approach-1",
    "title": "PDS Introduction",
    "section": "Prior approach #1",
    "text": "Prior approach #1\nChallenge: semantic frameworks don’t generally provide an apparatus for characterizing uncertainty about what we can mean in using linguistic expressions.\n\nResult: they have great difficulty characterizing:\n\nthe actual inferences that a language-comprehender draws;\nthe statistical patterns exhibited by these inferences (e.g., in a human inference dataset)."
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician’s assistant won’t admit that they laughed during the trick.\nDid the magician’s assistant laugh?"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-1",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-1",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician’s assistant won’t admit that they laughed during the trick.\nDid the magician’s assistant laugh?"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-2",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-2",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician’s assistant won’t admit that they laughed during the trick.\nDid the magician’s assistant laugh?"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-3",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-3",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician’s assistant won’t admit that they laughed during the trick.\nDid the magician’s assistant laugh?"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-4",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-4",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician’s assistant won’t admit that they laughed during the trick.\nDid the magician’s assistant laugh?"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-5",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-5",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician’s assistant won’t admit that they laughed during the trick.\nDid the magician’s assistant laugh?\n\n\nAverage response:"
  },
  {
    "objectID": "pds-intro/pds-intro.html#inferential-uncertainty-6",
    "href": "pds-intro/pds-intro.html#inferential-uncertainty-6",
    "title": "PDS Introduction",
    "section": "Inferential uncertainty",
    "text": "Inferential uncertainty\n\nThe magician’s assistant won’t admit that they laughed during the trick.\nDid the magician’s assistant laugh?\n\n\nAverage response:"
  },
  {
    "objectID": "pds-intro/pds-intro.html#prior-approach-2",
    "href": "pds-intro/pds-intro.html#prior-approach-2",
    "title": "PDS Introduction",
    "section": "Prior approach #2",
    "text": "Prior approach #2\nFrameworks for probabilistic semantics and pragmatics provide powerful tools for characterizing uncertainty about what we can mean in using linguistics expressions:\n\nsampling from and querying arbitrary probability distributions\nrelating the output to (e.g., human) data\nformal model comparison\n\n\nChallenge: no general structure-preserving method for mapping between semantic analyses and probabilistic analyses."
  },
  {
    "objectID": "pds-intro/pds-intro.html#probabilistic-dynamic-semantics",
    "href": "pds-intro/pds-intro.html#probabilistic-dynamic-semantics",
    "title": "PDS Introduction",
    "section": "“Probabilistic Dynamic Semantics”",
    "text": "“Probabilistic Dynamic Semantics”\nGoal: framework where probabilistic reasoning can be added to a semantic analysis without changing its structure.\n\nResult:\n\ncharacterize and distinguish difference sources of uncertainty\nuse existing semantic theories by plugging them into the framework\nformally compare different semantic theories with each other"
  },
  {
    "objectID": "pds-intro/pds-intro.html#a-general-goal",
    "href": "pds-intro/pds-intro.html#a-general-goal",
    "title": "PDS Introduction",
    "section": "A general goal",
    "text": "A general goal\n\nHave a methodology that is widely available to linguists working on meaning.\n\n\nLarge-scale inference datasets are becoming more and more central to linguistic methodology, and semantic theory should keep up!\n\nTools to render semantic theories as probabilistic models can help catalyze things."
  },
  {
    "objectID": "pds-intro/pds-intro.html#the-basic-idea",
    "href": "pds-intro/pds-intro.html#the-basic-idea",
    "title": "PDS Introduction",
    "section": "The basic idea",
    "text": "The basic idea\nWe should think of an experimental trial as a little discourse."
  },
  {
    "objectID": "pds-intro/pds-intro.html#the-basic-idea-1",
    "href": "pds-intro/pds-intro.html#the-basic-idea-1",
    "title": "PDS Introduction",
    "section": "The basic idea",
    "text": "The basic idea\n\nSentences: Start with a prior distribution over parameters some kind (e.g., encoding world knowledge, basic meanings). Update this prior with \\(⟦\\textit{s1}⟧\\), then \\(⟦\\textit{s2}⟧\\), etc.\nQuestion: Add \\(⟦\\textit{q}⟧\\) to the stack of questions under discussion (Ginzburg 1996; Farkas and Bruce 2010).\nAnswer: Retrieve \\(⟦\\textit{q}⟧\\) from the question stack; respond (i.e., query an inference distribution)."
  },
  {
    "objectID": "pds-intro/pds-intro.html#upshot",
    "href": "pds-intro/pds-intro.html#upshot",
    "title": "PDS Introduction",
    "section": "Upshot",
    "text": "Upshot\nOnce we have modeled the entire discourse in terms of some semantic analysis, we end up with a distribution over answers to the question prompt.\n\nA distribution we can learn about from data."
  },
  {
    "objectID": "pds-intro/pds-intro.html#two-kinds-of-uncertainty",
    "href": "pds-intro/pds-intro.html#two-kinds-of-uncertainty",
    "title": "PDS Introduction",
    "section": "Two kinds of uncertainty",
    "text": "Two kinds of uncertainty\n\nresolved (or type-level) uncertainty\n\nlexical, structural, or semantic (e.g., scopal) ambiguity\n\nunresolved (or token-level) uncertainty\n\npresent on individual occasions of language use"
  },
  {
    "objectID": "pds-intro/pds-intro.html#example-of-resolved-uncertainty",
    "href": "pds-intro/pds-intro.html#example-of-resolved-uncertainty",
    "title": "PDS Introduction",
    "section": "Example of resolved uncertainty",
    "text": "Example of resolved uncertainty\n\nJo ran a race.\n\n\n\nlocomotion sense of ran\nmanagement/organizational sense of ran\n\n\nAbout nature of speech act."
  },
  {
    "objectID": "pds-intro/pds-intro.html#example-of-unresolved-uncertainty",
    "href": "pds-intro/pds-intro.html#example-of-unresolved-uncertainty",
    "title": "PDS Introduction",
    "section": "Example of unresolved uncertainty",
    "text": "Example of unresolved uncertainty\n\nJo is tall.\n\n\n\nuncertainty about Jo’s height\n\n\nIn some sense, independent of speech act."
  },
  {
    "objectID": "pds-intro/pds-intro.html#uncertainty-in-pds",
    "href": "pds-intro/pds-intro.html#uncertainty-in-pds",
    "title": "PDS Introduction",
    "section": "Uncertainty in PDS",
    "text": "Uncertainty in PDS\n\nProbability distributions may be “stacked”; this stacking is reflected in the types of semantic values.\n\nE.g., \\(\\P e\\) vs. \\(\\P (\\P e)\\).\n\nResolved uncertainty: about the state of some discourse.\n\n\\(\\P σ\\)\n\nUnresolved uncertainty: encoded in the common ground.\n\n\\(\\P ι\\) (\\(ι\\) the type of possible worlds)\nThe common ground is an aspect of the state! \\(\\P σ = \\P (… \\P ι …)\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#discourse-states",
    "href": "pds-intro/pds-intro.html#discourse-states",
    "title": "PDS Introduction",
    "section": "Discourse states",
    "text": "Discourse states\n\nLists of parameters - can be arbitrarily complex.\n\nThe common ground (or context set; Stalnaker (1978))\nThe question under discussion (Roberts 2012; Ginzburg 1996)\nFarkas and Bruce (2010) stuff (e.g., projected sets)\n(Whatever you want)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#common-grounds",
    "href": "pds-intro/pds-intro.html#common-grounds",
    "title": "PDS Introduction",
    "section": "Common grounds",
    "text": "Common grounds\n\nProbability distributions over indices of some type\n\nencode what is true “in the world” \nmaybe certain linguistic parameters\n\n\n\nStates vs. indices of the common ground\nWhat kind of thing goes where?\n\nUltimately, an empirical question."
  },
  {
    "objectID": "pds-intro/pds-intro.html#dynamic-semantics",
    "href": "pds-intro/pds-intro.html#dynamic-semantics",
    "title": "PDS Introduction",
    "section": "Dynamic semantics",
    "text": "Dynamic semantics\n\nSome linguist walked in. They gave a lecture.\n\n\nPopular idea\nMany frameworks for dynamic semantics model sentence meanings as maps from input states to sets of output states (e.g., Groenendijk and Stokhof 1991; Muskens 1996, i.a.).\n\n\n\n1st sentence: \\(λs.\\{ x{::}s^{\\prime} ∣ s^{\\prime} = s ∧ \\ct{ling}(x) ∧ \\ct{walk}(x)\\}\\)\n2nd sentence: \\(λs.\\{ s^{\\prime} ∣ s^{\\prime} = s ∧ \\ct{lecture}(\\ct{sel}(s))\\}\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#expressions-and-discourses",
    "href": "pds-intro/pds-intro.html#expressions-and-discourses",
    "title": "PDS Introduction",
    "section": "Expressions and discourses",
    "text": "Expressions and discourses\n\nmap discourse states onto probability distributions over new discourse states: \\(σ → \\P (α × σ^{\\prime})\\)\ncomplex linguistic acts may be sequenced\n\nan operation, bind, native to the probability monad\n\n\n\nFor instance\n\n\\(\\abbr{assert}(⟦\\textit{Jo is tall}⟧) : σ → \\P (⋄ × σ)\\)\n\\(\\abbr{ask}(⟦\\textit{how tall?}⟧) : σ → \\P (⋄ × \\Q ι r σ)\\)\n\\(\\abbr{assert}(⟦\\textit{Jo is tall}⟧) &gt;&gt; \\abbr{ask}(⟦\\textit{how tall?}⟧) : σ → \\P (⋄ × \\Q ι r σ)\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#response-functionslinking-models",
    "href": "pds-intro/pds-intro.html#response-functionslinking-models",
    "title": "PDS Introduction",
    "section": "Response functions/linking models",
    "text": "Response functions/linking models\n\nTake a discourse, together with a prior distribution over states…\nGive back a distribution over responses to the last question asked (given some testing instrument).\n\n\n\\[\n\\begin{align*}\n\\ct{respond} &: \\P σ → (σ → \\P (⋄ × \\Q ι α σ^{\\prime})) → \\P ρ\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#examples-of-linking-models",
    "href": "pds-intro/pds-intro.html#examples-of-linking-models",
    "title": "PDS Introduction",
    "section": "Examples of linking models",
    "text": "Examples of linking models\n\\[\n\\begin{align*}\n\\ct{respond} &: \\P σ → (σ → \\P (⋄ × \\Q ι α σ^{\\prime})) → \\P ρ\n\\end{align*}\n\\]\n\nLikert scale (categorical distribution); e.g., \\(ρ = \\{\\textit{yes}, \\textit{maybe}, \\textit{no}\\}\\)\nSlider scale (truncated normal distribution);  \\(ρ = r\\)\nBinary forced choice (Bernoulli distribution);  \\(ρ = t\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#ccg",
    "href": "pds-intro/pds-intro.html#ccg",
    "title": "PDS Introduction",
    "section": "CCG",
    "text": "CCG\nAtomic types\n\\[\n\\begin{align*}\n\\mathcal{A} &\\Coloneqq np ∣ n ∣ s ∣\\,\\,...\n\\end{align*}\n\\] Noun phrases (\\(np\\)), nouns (\\(n\\)), and sentences (\\(s\\)).\n\nComplex types\n\\[\n\\begin{align*}\n\\mathcal{C}_{\\mathcal{A}} &\\Coloneqq \\mathcal{A} ∣ \\mathcal{C}_{\\mathcal{A}}/\\mathcal{C}_{\\mathcal{A}} ∣ \\mathcal{C}_{\\mathcal{A}}\\backslash\\mathcal{C}_{\\mathcal{A}}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell",
    "href": "pds-intro/pds-intro.html#haskell",
    "title": "PDS Introduction",
    "section": "Haskell",
    "text": "Haskell\n\ndata Cat = Base String  -- atomic categories\n         | Cat :/: Cat  -- the forward slash\n         | Cat :\\: Cat  -- the backward slash\n  deriving (Eq)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#ccg-expressions",
    "href": "pds-intro/pds-intro.html#ccg-expressions",
    "title": "PDS Introduction",
    "section": "CCG expressions",
    "text": "CCG expressions\nAn expression:\n\\[\\Large\n\\begin{align*}\n  \\expr{\\textit{dog}}{λx, i.\\ct{dog}(i)(x)}{n}\n\\end{align*}\n\\]\n\n\\(\\textit{dog}\\) is a string.\n\\(λx, i.\\ct{dog}(i)(x)\\) is a meaning (reprented in the λ-calculus).\n\nIts type is \\(e → ι → t\\).\n\n\\(n\\) is a CCG category."
  },
  {
    "objectID": "pds-intro/pds-intro.html#semantic-types-in-detail",
    "href": "pds-intro/pds-intro.html#semantic-types-in-detail",
    "title": "PDS Introduction",
    "section": "Semantic types (in detail)",
    "text": "Semantic types (in detail)\n\nAtomic types\n\\[\n\\begin{align*}\nA \\Coloneqq e ∣ t ∣\\,\\,...\n\\end{align*}\n\\]\n\n\nComplex types\n\\[\n\\begin{align*}\n   \\mathcal{T}_{A} \\Coloneqq A ∣ \\mathcal{T}_{A} → \\mathcal{T}_{A} ∣ \\mathcal{T}_{A} × \\mathcal{T}_{A} ∣ ⋄\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-1",
    "href": "pds-intro/pds-intro.html#haskell-1",
    "title": "PDS Introduction",
    "section": "Haskell",
    "text": "Haskell\ndata Type = Atom String  -- atomic types\n          | Type :→ Type -- arrows\n          | Unit         -- unit type\n          | Type :× Type -- products\n          | TyVar String -- type variables\n  deriving (Eq)\n\nNote the type variables!"
  },
  {
    "objectID": "pds-intro/pds-intro.html#typing-rules",
    "href": "pds-intro/pds-intro.html#typing-rules",
    "title": "PDS Introduction",
    "section": "Typing rules",
    "text": "Typing rules\n \\[ \\scriptsize\n\\begin{array}{c}\n\\begin{prooftree}\n\\AxiomC{}\n\\RightLabel{$\\mathtt{Ax}$}\\UnaryInfC{$Γ, x : α ⊢ x : α$}\n\\end{prooftree}\n& \\begin{prooftree}\n\\AxiomC{$Γ, x : α ⊢ t : β$}\n\\RightLabel{${→}\\mathtt{I}$}\\UnaryInfC{$Γ ⊢ λx.t : α → β$}\n\\end{prooftree}\n& \\begin{prooftree}\n\\AxiomC{$Γ ⊢ t : α → β$}\n\\AxiomC{$Γ ⊢ u : α$}\n\\RightLabel{${→}\\mathtt{E}$}\\BinaryInfC{$Γ ⊢ t(u) : β$}\n\\end{prooftree} \\\\[2mm]\n\\begin{prooftree}\n\\AxiomC{}\n\\RightLabel{$⋄\\mathtt{I}$}\\UnaryInfC{$Γ ⊢ ⋄ : ⋄$}\n\\end{prooftree}\n& \\begin{prooftree}\n\\AxiomC{$Γ ⊢ t : α$}\n\\AxiomC{$Γ ⊢ u : β$}\n\\RightLabel{$×\\mathtt{I}$}\\BinaryInfC{$Γ ⊢ ⟨t, u⟩ : α × β$}\n\\end{prooftree}\n& \\begin{prooftree}\n\\AxiomC{$Γ ⊢ t : α_1 × α_2$}\n\\RightLabel{$×\\mathtt{E}_{j}$}\\UnaryInfC{$Γ ⊢ π_{j}(t) : α_{j}$}\n\\end{prooftree}\n\\end{array}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#typing-rules-1",
    "href": "pds-intro/pds-intro.html#typing-rules-1",
    "title": "PDS Introduction",
    "section": "Typing rules",
    "text": "Typing rules\n\\(→\\mathtt{E}\\)\n \\[\n\\begin{prooftree}\n\\AxiomC{$Γ ⊢ t : α → β$}\n\\AxiomC{$Γ ⊢ u : α$}\n\\RightLabel{${→}\\mathtt{E}$}\\BinaryInfC{$Γ ⊢ t(u) : β$}\n\\end{prooftree}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-vanilla-terms",
    "href": "pds-intro/pds-intro.html#haskell-vanilla-terms",
    "title": "PDS Introduction",
    "section": "Haskell: vanilla terms",
    "text": "Haskell: vanilla terms\n-- | Untyped λ-terms. Types are assigned separately (i.e., \"extrinsically\").\ndata Term = Var VarName           -- Variables.\n          | Con Constant          -- Constants.\n          | Lam VarName Term      -- Abstractions.\n          | App Term Term         -- Applications.\n          | TT                    -- The 0-tuple.\n          | Pair Term Term        -- Pairing.\n          | Pi1 Term              -- First projection.\n          | Pi2 Term              -- Second projection.\n\nConstants:\n-- | Constants are indexed by either strings or real numbers.\ntype Constant = Either String Double"
  },
  {
    "objectID": "pds-intro/pds-intro.html#deriving-meanings",
    "href": "pds-intro/pds-intro.html#deriving-meanings",
    "title": "PDS Introduction",
    "section": "Deriving meanings",
    "text": "Deriving meanings\n\nType homomorphism\n\n\\(\\small ⟦np⟧ = e \\hspace{2cm} ⟦n⟧ = e → ι → t \\hspace{2cm} ⟦s⟧ = ι → t\\) \n\\(\\small ⟦b / a⟧ = ⟦b \\backslash a⟧ = ⟦a⟧ → ⟦b⟧\\)\n\n\n\nExample: application\n\n\\[\\scriptsize\n\\frac{\\expr{\\textit{every}}{λp^{e → ι → t}, q^{e → ι → t}, i^{ι}.(∀y.p(y)(i) → q(y)(i))^{t}}{s}/(s\\backslash np)/ n \\hspace{1cm} \\expr{\\textit{linguist}}{λx^{e}, i^{ι}.(\\ct{ling}(i)(x))^{t}}{n}}{\n\\expr{\\textit{every linguist}}{λq^{e → ι → t}, i^{ι}.(∀y.\\ct{ling}(i)(y) → q(y)(i))^{t}}{s}/(s\\backslash np)\n}&gt;\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#adding-probabilistic-types",
    "href": "pds-intro/pds-intro.html#adding-probabilistic-types",
    "title": "PDS Introduction",
    "section": "Adding probabilistic types",
    "text": "Adding probabilistic types\n\nNew atomic types\n\\[\nA \\Coloneqq e ∣ t ∣ r ∣\\,\\,...\n\\]\n\n\nNew complex types\n\\[\n\\mathcal{T}_{A} \\Coloneqq A ∣ \\mathcal{T}_{A} → \\mathcal{T}_{A} ∣ \\mathcal{T}_{A} × \\mathcal{T}_{A} ∣ ⋄ ∣ \\P \\mathcal{T}_{A}\n\\]\n\n\\(\\P t\\): a Bernoulli distribution—probabilistically True or False.\n\\(\\P r\\): e.g., a normal distribution."
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-2",
    "href": "pds-intro/pds-intro.html#haskell-2",
    "title": "PDS Introduction",
    "section": "Haskell",
    "text": "Haskell\ndata Type = Atom String  -- atomic types\n          | Type :→ Type -- arrows\n          | Unit         -- unit type\n          | Type :× Type -- products\n          | P Type       -- probabilistic types\n          | TyVar String -- type variables\n  deriving (Eq)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#probabilistic-typing-rules",
    "href": "pds-intro/pds-intro.html#probabilistic-typing-rules",
    "title": "PDS Introduction",
    "section": "Probabilistic typing rules",
    "text": "Probabilistic typing rules\n \\[\n\\begin{array}{c}\n\\begin{prooftree}\n\\AxiomC{$Γ ⊢ t : α$}\n\\RightLabel{$\\mathtt{Return}$}\\UnaryInfC{$Γ ⊢ \\pure{t} : \\P α$}\n\\end{prooftree}\n& \\begin{prooftree}\n\\AxiomC{$Γ ⊢ t : \\P α$}\n\\AxiomC{$Γ, x : α ⊢ u : \\P β$}\n\\RightLabel{$\\mathtt{Bind}$}\\BinaryInfC{$Γ ⊢ \\left(\\begin{array}{l} x ∼ t \\\\ u\\end{array}\\right) : \\P β$}\n\\end{prooftree}\n\\end{array}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-probabilistic-programs",
    "href": "pds-intro/pds-intro.html#haskell-probabilistic-programs",
    "title": "PDS Introduction",
    "section": "Haskell: probabilistic programs",
    "text": "Haskell: probabilistic programs\n-- | Untyped λ-terms. Types are assigned separately (i.e., \"extrinsically\").\ndata Term = Var VarName           -- Variables.\n          | Con Constant          -- Constants.\n          | Lam VarName Term      -- Abstractions.\n          | App Term Term         -- Applications.\n          | TT                    -- The 0-tuple.\n          | Pair Term Term        -- Pairing.\n          | Pi1 Term              -- First projection.\n          | Pi2 Term              -- Second projection.\n          | Return Term           -- Construct a degenerate distribution.\n          | Let VarName Term Term -- Sample from a distribution and continue.\n\nLet x t u    =    \\(\\begin{array}[t]{l}\nx ∼ t \\\\\nu\n\\end{array}\\)\nReturn t    =    \\(\\pure{t}\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#making-observations",
    "href": "pds-intro/pds-intro.html#making-observations",
    "title": "PDS Introduction",
    "section": "Making observations",
    "text": "Making observations\n\\[\n\\begin{align*}\n\\ct{observe}\\ \\ &:\\ \\ t → \\P ⋄ \\\\\n\\end{align*}\n\\]\n\n\\[\n\\begin{array}[t]{l}\nx ∼ \\ct{Normal}(0, 1) \\\\\n\\ct{observe}(-1 ≤ x ≤ 1) \\\\\n\\pure{x}\n\\end{array}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#making-observations-1",
    "href": "pds-intro/pds-intro.html#making-observations-1",
    "title": "PDS Introduction",
    "section": "Making observations",
    "text": "Making observations\n\\[\n\\begin{align*}\n\\ct{observe}\\ \\ &:\\ \\ t → \\P ⋄ \\\\\n\\end{align*}\n\\]\n\\[\n\\begin{array}[t]{l}\nx ∼ \\ct{Normal}(0, 1) \\\\\n\\ct{observe}(-1 ≤ x ≤ 1) \\\\\n\\pure{x}\n\\end{array}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-typing-constants",
    "href": "pds-intro/pds-intro.html#haskell-typing-constants",
    "title": "PDS Introduction",
    "section": "Haskell: typing constants",
    "text": "Haskell: typing constants\n-- | Assign types to constants.\ntype Sig = Constant -&gt; Maybe Type\n\n\nAn example signature\ne, t, r :: Type\ne = At E\nt = At T\nr = At R\n\ntau :: Sig\ntau = \\case\n  Left  \"observe\"   -&gt; Just (t :→ P Unit)\n  Left  \"Normal\"    -&gt; Just (r :× r → P r)\n  Left  \"Bernoulli\" -&gt; Just (r :→ P t)\n  Left  \"mother\"    -&gt; Just (e :→ e)\n  Right _           -&gt; Just r"
  },
  {
    "objectID": "pds-intro/pds-intro.html#types-of-expressions",
    "href": "pds-intro/pds-intro.html#types-of-expressions",
    "title": "PDS Introduction",
    "section": "Types of expressions",
    "text": "Types of expressions\n\\[\\Large\nσ → \\P (α × σ^{\\prime})\n\\]\n\n\\(α\\) could be:\n\n\\(e → ι → t \\hspace{2cm}\\) (a predicate meaning)\n\\(e \\hspace{7cm}\\) (a np meaning)\netc."
  },
  {
    "objectID": "pds-intro/pds-intro.html#an-interface-for-meaning-composition",
    "href": "pds-intro/pds-intro.html#an-interface-for-meaning-composition",
    "title": "PDS Introduction",
    "section": "An interface for meaning composition",
    "text": "An interface for meaning composition\n\\[\n\\begin{align*}\nℙ^{σ}_{σ^{\\prime}} α\\ \\ &=\\ \\ σ → \\P (α × σ^{\\prime})\n\\end{align*}\n\\]\n\n\\[\n\\begin{align*}\n\\return{v}\\ \\ &=\\ \\ λs.\\pure{⟨v, s⟩} : ℙ^{σ}_{σ}\n\\end{align*}\n\\]\n\n\n\\[\n\\begin{align*}\n\\begin{array}{rl}\n\\Do & x ← m : ℙ^{σ}_{σ^{\\prime}} \\\\\n& k(x) : ℙ^{σ^{\\prime}}_{σ^{\\prime\\prime}}\n\\end{array}\\ \\\n&=\\ \\ λs.\\left(\\begin{array}{l}\n⟨x, s^{\\prime}⟩ ∼ m(s) \\\\\nk(x)(s^{\\prime})\n\\end{array}\\right) : ℙ^{σ}_{σ^{\\prime\\prime}}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#types-of-expressions-1",
    "href": "pds-intro/pds-intro.html#types-of-expressions-1",
    "title": "PDS Introduction",
    "section": "Types of expressions",
    "text": "Types of expressions\n\nJo ran a race.\n\n\n\\(⟦\\textit{run}⟧ : ℙ^{σ}_{σ} (e → ι → t)\\)\n\n\n\\[\n\\expr{\\textit{run}}{λs.\\pure{⟨λx, i.\\ct{if\\_then\\_else}(τ_{\\textit{run}}(s))(\\ct{run}_{loc.}(i)(x), \\ct{run}_{org.}(i)(x)), s⟩}}{s \\backslash np}\n\\]\n\n\nDepends on the state.\nDoesn’t update it.\nNot very probabilistic."
  },
  {
    "objectID": "pds-intro/pds-intro.html#pds-rules",
    "href": "pds-intro/pds-intro.html#pds-rules",
    "title": "PDS Introduction",
    "section": "PDS Rules",
    "text": "PDS Rules\nExample: leftward application\n\\[\n\\begin{prooftree}\n\\AxiomC{$\\expr{s_{1}}{M_{1}}{b}$}\n\\AxiomC{$\\expr{s_{2}}{M_{2}}{c\\backslash b}$}\n\\RightLabel{$&lt;$}\\BinaryInfC{$\\expr{s_{1}\\,s_{2}}{\n\\begin{array}{rl}\n\\Do & m_{1} ← M_{1} \\\\\n& m_{2} ← M_{2}; \\\\\n& \\return{m_{2}(m_{1})}\n\\end{array}\n}{c}$}\n\\end{prooftree}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#a-sentence-meaning",
    "href": "pds-intro/pds-intro.html#a-sentence-meaning",
    "title": "PDS Introduction",
    "section": "A sentence meaning",
    "text": "A sentence meaning\n\nA linguist saw a philosopher.\n\n\n\\[\\tiny\\hspace{-6cm}\n\\begin{prooftree}\n\\AxiomC{$\\expr{\\textit{a ling.}}{λs.\\pure{⟨λi, k.∃x.\\ct{ling}(i)(x) ∧ k(i)(x), s⟩}}{s/(s\\backslash np)}$}\n\\AxiomC{$\\expr{\\textit{saw}}{λs.\\pure{⟨λi, y, x.\\ct{see}(i)(y)(x), s⟩}}{s\\backslash np/ np}$}\n\\AxiomC{$\\expr{\\textit{a phil.}}{λs.\\pure{⟨λi, k, x.∃y.\\ct{phil}(i)(y) ∧ k(i)(y)(x), s⟩}}{s\\backslash np/(s\\backslash np/np)}$}\n\\RightLabel{$&lt;$}\\BinaryInfC{$\\expr{\\textit{saw a phil.}}{λs.\\pure{⟨λx, i.∃y.\\ct{phil}(i)(y) ∧ \\ct{see}(i)(y)(x), s⟩}}{s \\backslash np}$}\n\\RightLabel{$&lt;$}\\BinaryInfC{$\\expr{\\textit{a linguist saw a philosopher}}{λs.\\pure{⟨λi.∃x, y.\\ct{ling}(i)(x) ∧ \\ct{phil}(i)(y) ∧ \\ct{see}(i)(y)(x), s⟩}}{s}$}\n\\end{prooftree}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#a-sentence-meaning-1",
    "href": "pds-intro/pds-intro.html#a-sentence-meaning-1",
    "title": "PDS Introduction",
    "section": "A sentence meaning",
    "text": "A sentence meaning\n\n\\[\n\\expr{\\textit{a linguist saw a philosopher}}{λs.\\pure{⟨λi.∃x, y.\\ct{ling}(i)(x) ∧ \\ct{phil}(i)(y) ∧ \\ct{see}(i)(y)(x), s⟩}}{s}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#intensionality",
    "href": "pds-intro/pds-intro.html#intensionality",
    "title": "PDS Introduction",
    "section": "Intensionality",
    "text": "Intensionality\nIntensional constants:\n\\[\n\\begin{align*}\n\\ct{see} &: ι → e → e → t \\\\\n\\ct{ling} &: ι → e → t\n\\end{align*}\n\\]\n\nWe require other constants:\n\\[\n\\begin{align*}\n\\updct{see} &: (e → e → t) → ι → ι \\\\\n\\updct{ling} &: (e → t) → ι → ι\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#how-intensional-constants-interact",
    "href": "pds-intro/pds-intro.html#how-intensional-constants-interact",
    "title": "PDS Introduction",
    "section": "How intensional constants interact",
    "text": "How intensional constants interact\n\n\\[\n\\ct{see}(\\updct{see}(p)(i)) = p \\\\\n\\]\n\n\n\\[\n\\ct{see}(\\updct{ling}(p)(i)) = \\ct{see}(i)\n\\]\n\n\n\\[\n\\ct{ling}(\\updct{ling}(p)(i)) = p \\\\\n\\]\n\n\n\\[\n\\ct{ling}(\\updct{see}(p)(i)) = \\ct{ling}(i)\n\\]\n\nCan be seen as a theory of states and locations.\n\nIndices are “states”.\n(Pairs of) constants correspond to “locations”."
  },
  {
    "objectID": "pds-intro/pds-intro.html#the-common-ground",
    "href": "pds-intro/pds-intro.html#the-common-ground",
    "title": "PDS Introduction",
    "section": "The common ground",
    "text": "The common ground\nDefinition\nA common ground is a probabilistic program of type \\(\\P ι\\).\n\n\\(ι\\), a variable over types.\n\n\nA “starting” index\n\\[\\ct{@} : ι\\]\n\nConstants that update indices can add information, to be later retrieved by intensional constants."
  },
  {
    "objectID": "pds-intro/pds-intro.html#states",
    "href": "pds-intro/pds-intro.html#states",
    "title": "PDS Introduction",
    "section": "States",
    "text": "States\nSome state-sensitive constants:\n\n\\[\n\\ct{CG} : σ → \\P ι \\\\\n\\]\n\n\n\\[\n\\updct{CG} : \\P ι → σ → σ \\\\\n\\]\n\n\n\\[\n\\ct{QUD} : \\Q ι α σ → α → ι → t\n\\]\n\n\n\\[\n\\updct{QUD} : (α → ι → t) → σ → \\Q ι α σ\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-the-q-constructor",
    "href": "pds-intro/pds-intro.html#haskell-the-q-constructor",
    "title": "PDS Introduction",
    "section": "Haskell: the \\(\\Q\\) constructor",
    "text": "Haskell: the \\(\\Q\\) constructor\n\n-- | Arrows, products, and probabilistic types, as well as (a) abstract types\n-- representing the addition of a new Q, and (b) type variables for encoding\n-- polymorphism.\ndata Type = At Atom\n          | Type :→ Type\n          | Unit\n          | Type :× Type\n          | P Type\n          | Q Type Type Type\n          | TyVar String\n  deriving (Eq)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#how-stateful-constants-interact",
    "href": "pds-intro/pds-intro.html#how-stateful-constants-interact",
    "title": "PDS Introduction",
    "section": "How stateful constants interact",
    "text": "How stateful constants interact\n\\[\n\\ct{CG}(\\updct{CG}(cg)(s)) = cg\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#manipulating-stateful-programs",
    "href": "pds-intro/pds-intro.html#manipulating-stateful-programs",
    "title": "PDS Introduction",
    "section": "Manipulating stateful programs",
    "text": "Manipulating stateful programs\n\\(\\ct{get}\\) and \\(\\ct{put}\\)\n\\[\n\\begin{align*}\n\\abbr{get} &: ℙ^{σ}_{σ} σ\n\\end{align*}\n\\]\n\nGets the current state.\n\n\n\\[\n\\begin{align*}\n\\abbr{put} &: σ^{\\prime} → ℙ^{σ}_{σ^{\\prime}} ⋄ \\\\\n\\end{align*}\n\\]\n\nOverwrites the current state with a new one."
  },
  {
    "objectID": "pds-intro/pds-intro.html#haskell-3",
    "href": "pds-intro/pds-intro.html#haskell-3",
    "title": "PDS Introduction",
    "section": "Haskell",
    "text": "Haskell\n\ngetPP :: Term\ngetPP = lam' s (Return (s & s))\n\nputPP :: Term -&gt; Term\nputPP s = Lam fr (Return (TT & s))\n  where fr:esh = fresh [s]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#asking-a-question",
    "href": "pds-intro/pds-intro.html#asking-a-question",
    "title": "PDS Introduction",
    "section": "Asking a question",
    "text": "Asking a question\n\\[\n\\begin{align*}\n\\abbr{ask} &: ℙ^{σ}_{σ^{\\prime}} (α → ι → t) → ℙ^{σ}_{\\Q ι α σ^{\\prime}} ⋄\n\\end{align*}\n\\]\n\n\\[\n\\begin{align*}\n\\abbr{ask}(⟦\\textit{how tall?}⟧) &= \\begin{array}[t]{rl}\n\\Do & q^{r → ι → t} ← ⟦\\textit{how tall?}⟧^{ℙ^{σ}_{σ}(r → ι → t)} \\\\\n& s ← \\abbr{get} \\\\\n& \\abbr{put}(\\updct{QUD}(q)(s))\n\\end{array}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#responding-to-a-question",
    "href": "pds-intro/pds-intro.html#responding-to-a-question",
    "title": "PDS Introduction",
    "section": "Responding to a question",
    "text": "Responding to a question\n\n\\[\n\\begin{align*}\n\\abbr{respond}^{f_Φ : r → \\P ρ} &: \\P σ → ℙ^{σ}_{\\Q ι r σ^{\\prime}} ⋄ → \\P ρ\n\\end{align*}\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#responding-to-a-question-1",
    "href": "pds-intro/pds-intro.html#responding-to-a-question-1",
    "title": "PDS Introduction",
    "section": "Responding to a question",
    "text": "Responding to a question\n\\[\n\\begin{align*}\n&\\abbr{respond}^{f_Φ : r → \\P ρ}(prior)(discourse) \\\\[5mm]\n&= \\begin{array}[t]{l}\ns ∼ prior \\\\\n⟨⋄, s^{\\prime}⟩ ∼ discourse(s)\\\\\ni ∼ \\ct{CG}(s^{\\prime}) \\\\\nf(\\ct{max}(λd.\\ct{QUD}(s^{\\prime})(d)(i)), Φ)\n\\end{array}\n\\end{align*}\n\\]\n\nExample \\(f_{Φ}\\)\n\n\\(f(x, Φ) = \\ct{Normal}(x, 1)\\)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#a-probabilistic-model",
    "href": "pds-intro/pds-intro.html#a-probabilistic-model",
    "title": "PDS Introduction",
    "section": "A probabilistic model",
    "text": "A probabilistic model\n\\[\n\\begin{align*}\n\\abbr{respond}^{f_Φ : r → \\P ρ} &: \\P σ → ℙ^{σ}_{\\Q ι r σ^{\\prime}} ⋄ → \\P ρ\n\\end{align*}\n\\]\n\\[\n\\abbr{respond}^{λx.\\ct{Normal}(x, 1)}(prior)\\left(\n\\begin{array}{rl}\n\\Do & \\abbr{assert}(⟦\\textit{Jo is tall}⟧) \\\\\n& \\abbr{ask}(⟦\\textit{how tall?}⟧)\n\\end{array}\n\\right)\n\\]"
  },
  {
    "objectID": "pds-intro/pds-intro.html#how-do-we-actually-compute-this-stuff",
    "href": "pds-intro/pds-intro.html#how-do-we-actually-compute-this-stuff",
    "title": "PDS Introduction",
    "section": "How do we actually compute this stuff?",
    "text": "How do we actually compute this stuff?\n\n\nDelta-rules.\n-- | The type of Delta-rules.\ntype DeltaRule = Term -&gt; Maybe Term"
  },
  {
    "objectID": "pds-intro/pds-intro.html#summing-up",
    "href": "pds-intro/pds-intro.html#summing-up",
    "title": "PDS Introduction",
    "section": "Summing up",
    "text": "Summing up\n\nWe have a computational framework for:\n\nencoding grammar fragments\nrepresenting speech acts (assertions, questions)\nrepresenting theories linking inferences to behavior (as response functions)\ncomputing with the resulting probabilistic programs (via delta-rules)"
  },
  {
    "objectID": "pds-intro/pds-intro.html#references",
    "href": "pds-intro/pds-intro.html#references",
    "title": "PDS Introduction",
    "section": "",
    "text": "References\n\n\n\n\nFarkas, Donka F., and Kim B. Bruce. 2010. “On Reacting to Assertions and Polar Questions.” Journal of Semantics 27 (1): 81–118. https://doi.org/10.1093/jos/ffp010.\n\n\nGinzburg, Jonathan. 1996. “Dynamics and the Semantics of Dialogue.” In Logic, Language, and Computation, edited by Jerry Seligman and Dag Westerståhl, 1:221–37. Stanford: CSLI Publications.\n\n\nGroenendijk, Jeroen A., and Martin B. J. Stokhof. 1991. “Dynamic Predicate Logic.” Linguistics and Philosophy 14 (1): 39–100. https://doi.org/10.1007/BF00628304.\n\n\nMuskens, Reinhard. 1996. “Combining Montague Semantics and Discourse Representation.” Linguistics and Philosophy 19 (2): 143–86. https://doi.org/10.1007/BF00635836.\n\n\nRoberts, Craige. 2012. “Information Structure: Towards an Integrated Formal Theory of Pragmatics.” Semantics and Pragmatics 5 (December): 6:1–69. https://doi.org/10.3765/sp.5.6.\n\n\nStalnaker, Robert. 1978. “Assertion.” In Pragmatics, edited by Peter Cole, 9:315–32. New York: Academic Press."
  }
]